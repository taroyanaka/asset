<!DOCTYPE html>
1
<!-- 自動で探索するテストコードの方針
 全自動の際は クリア不可 中間 クリア簡単 のグラデーションを作るようなエネミーリストを複数用意する
    全部戦う選択=>休憩選択肢を全て組み合わせ選択=>全部戦う　繰り返し で全クリできるか
    全部任意(orランダム選択)スペル(mp切れの際は戦う) => 休憩選択肢を全て組み合わせ選択 => 繰り返し　で全クリできるか
 半手動テスト(任意のレベル帯を選択してスペルアイテムを駆使してクリアできるか)
 それぞれのオブジェクトが正しく動作するか 各休憩イベント スペル アイテム　アクセサリ
    それぞれのオブジェクトが明らかな不快ではないか(おそらく休憩イベントを仕様変更する)(スペルはゲームバランス考えずにリリースまでやる)
 -->

<!-- spellの種類100から10に、エネミー最大レベル半分にする、
    とりあえずリリースまで駆け抜ける 2作か3作目で当たり狙いに行く
    (dlsiteがandroidのアプリ審査みたいにクソのションベン煮込みではないことをまず確かめる)
     -->
<html lang="ja">
<script>
// let test = true; // テストモードのフラグ
const test = false;
</script>
<head>
  <meta charset="UTF-8">
  <title>ターンバトル</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: sans-serif;
      padding: 20px;
      display: flex; /* フレックスボックスでレイアウト */
    }
    .left-column {
      width: 30%; /* 左カラムの幅 */
      margin-right: 10px;
    }
    .right-column {
      width: 70%; /* 右カラムの幅 */
      display: flex;
      flex-direction: column;
    }
    .log {
      height: 90vh;
      overflow-y: auto;
      border: 1px solid #0f0;
      padding: 10px;
    }
    .stats, .actions, .enemies {
      margin-bottom: 10px;
      border: 1px solid #0f0;
      padding: 10px;
    }
    button {
      margin: 2px;
    }
    .enemy {
      display: inline-block;
      border: 1px solid #0f0;
      padding: 5px;
      margin: 2px;
    }
    .dead {
      opacity: 0.5;
    }
    /* ボタンを全て2倍の大きさにする */
    button {
      font-size: 2em;
      padding: 10px 20px;
      margin: 5px;
      background-color: #0f0;
      color: #000;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

  </style>
</head>
<body>
  <div class="left-column">
    <!-- テストモード用設定UI -->
    <!-- <div id="test-settings">
        <button id="btn-test" onclick="tradeHpMp_TEST_prepara_and_exe()">tradeHpMp_TEST(done)</button>
        <button id="btn-test" onclick="tradeHpMpAll_TEST_prepara_and_exe()">tradeHpMpAll_TEST(done)</button>
        <button id="btn-test" onclick="tradeMp_TEST_prepara_and_exe()">tradeMp_TEST(done)</button>
        <button id="btn-test" onclick="tradeMaxMp_TEST_prepara_and_exe()">tradeMaxMp_TEST(done)</button>
        <button id="btn-test" onclick="tradeMpAll_TEST_prepara_and_exe()">tradeMpAll_TEST(done)</button>
        <button id="btn-test" onclick="tradeMaxMpAll_TEST_prepara_and_exe()">tradeMaxMpAll_TEST(done)</button>
        <button id="btn-test" onclick="strBuff_TEST_prepara_and_exe()">strBuff_TEST(done)</button>
        <button id="btn-test" onclick="tradeMpByStr_TEST_prepara_and_exe()">tradeMpByStr_TEST(done)</button>
        <button id="btn-test" onclick="tradeMaxMpByStr_TEST_prepara_and_exe()">tradeMaxMpByStr_TEST(done)</button>
        <button id="btn-test" onclick="tradeMpAllByStr_TEST_prepara_and_exe()">tradeMpAllByStr_TEST(done)</button>
        <button id="btn-test" onclick="buffStrByEnemyCount_TEST_prepara_and_exe()">buffStrByEnemyCount_TEST(done)</button>
        <button id="btn-test" onclick="buffStrByEnemyCount2_TEST_prepara_and_exe()">buffStrByEnemyCount2_TEST(done)</button>

        <button id="btn-test" onclick="buffStrByAllCount_TEST_prepara_and_exe()">buffStrByAllCount_TEST</button>
        <button id="btn-test" onclick="buffStrByAllCount2_TEST_prepara_and_exe()">buffStrByAllCount2_TEST</button>
        <button id="btn-test" onclick="buffStrByAllCount3_TEST_prepara_and_exe()">buffStrByAllCount3_TEST</button>
        <button id="btn-test" onclick="buffStrByItemCount_TEST_prepara_and_exe()">buffStrByItemCount_TEST</button>
        <button id="btn-test" onclick="buffStrByItemCount2_TEST_prepara_and_exe()">buffStrByItemCount2_TEST</button>
        <button id="btn-test" onclick="buffStrByBattleCount_TEST_prepara_and_exe()">buffStrByBattleCount_TEST</button>
        <button id="btn-test" onclick="buffStrByBattleCount2_TEST_prepara_and_exe()">buffStrByBattleCount2_TEST</button>
        <button id="btn-test" onclick="buffStrByBattleCount3_TEST_prepara_and_exe()">buffStrByBattleCount3_TEST</button>
        <button id="btn-test" onclick="buffStrByBattleCount4_TEST_prepara_and_exe()">buffStrByBattleCount4_TEST</button>

        <label>HP倍率: <input id="input-hp-mult" type="number" step="0.01" value="1"></label><br>
        <label>EXP倍率: <input id="input-exp-mult" type="number" step="0.01" value="1"></label><br>
        <label>初期ヒーロー数: <input id="input-initial-heroes-volume" type="number" value="1"></label><br>
        <label>最大ヒーロー数: <input id="input-max-heroes" type="number" value="7"></label><br>
        <label>ドロップ数: <input id="input-volume-drops" type="number" value="1"></label><br>
        <label>ステータスの割合: <input id="input-str-percentage" type="number" step="0.01" value="0.4"></label><br>
        <label>ステータス引き継ぎ割合: <input id="input-status-inheritance-ratio" type="number" step="0.01" value="0.4"></label><br>
        <label>敵の味方割合: <input id="input-enemy-friendly-per" type="number" value="50"></label><br>
        <label>アクセサリドロップ率: <input id="input-accessory-drop-rate" type="number" value="90"></label><br>
        <label>最大装備数: <input id="input-max-accessories-per-hero" type="number" value="1"></label><br>
        <label>敵の出現数の増加数: <input id="input-enemy-more-volume" type="number" value="3"></label><br>
        <label>敵の出現数の配列: <input id="input-enemy-array-volume" type="number" value="5"></label><br>
        <button id="btn-apply-settings" onclick="startBattle()">設定を適用</button>
    </div> -->
    <div class="log" id="log"></div>
  </div>

  <div class="right-column">
    <div class="stats" id="stats"></div>
    <div class="enemies" id="enemies"></div>
    <div class="actions" id="actions"></div>
  </div>

<script src="./spell.js"></script>
<script src="./spell_test.js"></script>
<script>
let seed = 45;
function rand(min, max) {
    seed = (seed * 9301 + 49297) % 233280;
    return Math.floor(seed / 233280 * (max - min + 1)) + min;
}

let JOBS = {
    戦士: { hp: 80, mp: 0 },
    僧侶: { hp: 60, mp: 20 },
    魔法使い: { hp: 50, mp: 30 },
    黒魔道士: { hp: 40, mp: 40 },
    白魔道士: { hp: 50, mp: 30 },
};
let JOB_GROWTH = {
    戦士: { maxHp: [5, 10], maxMp: [0, 0] },
    僧侶: { maxHp: [3, 6], maxMp: [3, 6] },
    魔法使い: { maxHp: [2, 5], maxMp: [4, 8] },
    黒魔道士: { maxHp: [0, 0], maxMp: [7, 12] },
    白魔道士: { maxHp: [0, 0], maxMp: [6, 10] },
};

let HP_MULTIPLIER = test ? 0.1 : 1; // HP倍率 test===trueの時はhpを0.1倍でexpを100倍(1行で)
let EXP_MULTIPLIER = test ? 100 : 1; // 経験値倍率 test===trueの時はhpを0.1倍でexpを100倍(1行で)
let INITIAL_HEROES_VOLUME = 3; // 初期ヒーローの数
let INITIAL_HEROES = [
    // ['サトウ', '戦士'],
    ['スズキ', '魔法使い'],
    ['タナカ', '僧侶'],
]; // 初期のヒーローの名前と職業を決めるテーブル
let ENEMY_MORE_VOLUME = 3; // 敵の出現数の増加数
let ENEMY_ARRAY_VOLUME = 3; // 敵の出現数の配列
let ENEMY_VOLUME_ARRAY = [1];
let MAX_HEROES = 7; // 最大ヒーロー数
let VOLUME_DROPS = 1; // 敵2体でVOLUME_DROPSが1ならdrop数は2
let STR_PERCENTAGE = 0.4; // ステータスの割合    
let STATUS_INHERITANCE_RATIO = 0.4; // 前職から引き継ぐステータスの割合
let ENEMY_FRIENDLY_PER = test ? 100 : 50;
let ACCESSORY_DROP_RATE = 90; // アクセサリのドロップ確率（1体あたりのドロップ確率をパーセンテージで設定）90%の確率で1体あたりドロップ
let MAX_ACCESSORIES_PER_HERO = 1; // 1キャラ当たりの最大装備数

const log = document.getElementById('log');
const stats = document.getElementById('stats');
const enemiesDiv = document.getElementById('enemies');
const actions = document.getElementById('actions');

// ゲームのテンポのために初期レベル帯のエネミーの経験値は高く設定
let ENEMY_LIST = [
{"name": "スライム","level": 1,"hp": 20,"mp": 0,"exp": 50,"maxHp": 20,"maxMp": 0,"str": 8,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "戦士","jobHistory": {"戦士": 0},"accessories": []},
{"name": "バンシー","level": 1,"hp": 20,"mp": 20,"exp": 50,"maxHp": 20,"maxMp": 20,"str": 12,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "白魔道士","jobHistory": {"白魔道士": 0},"accessories": []},
{"name": "コボルト","level": 1,"hp": 30,"mp": 0,"exp": 0,"maxHp": 30,"maxMp": 0,"str": 15,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "ゴブリン","level": 1,"hp": 40,"mp": 0,"exp": 90,"maxHp": 40,"maxMp": 0,"str": 12,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "バジリスク","level": 1,"hp": 35,"mp": 0,"exp": 100,"maxHp": 35,"maxMp": 0,"str": 14,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "戦士","jobHistory": {"戦士": 0},"accessories": []},
{"name": "ケルベロス","level": 1,"hp": 30,"mp": 0,"exp": 110,"maxHp": 30,"maxMp": 0,"str": 16,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "サイクロプス","level": 2,"hp": 60,"mp": 0,"exp": 30,"maxHp": 60,"maxMp": 0,"str": 18,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "戦士","jobHistory": {"戦士": 0},"accessories": []},
{"name": "リッチ","level": 2,"hp": 50,"mp": 0,"exp": 28,"maxHp": 50,"maxMp": 0,"str": 14,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "黒魔道士","jobHistory": {"黒魔道士": 0},"accessories": []},
{"name": "ウォーロック","level": 2,"hp": 31,"mp": 0,"exp": 32,"maxHp": 31,"maxMp": 0,"str": 10,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "戦士","jobHistory": {"戦士": 0},"accessories": []},
{"name": "キメラ","level": 2,"hp": 49,"mp": 15,"exp": 40,"maxHp": 49,"maxMp": 15,"str": 20,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "タロス","level": 2,"hp": 65,"mp": 0,"exp": 44,"maxHp": 65,"maxMp": 0,"str": 22,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "黒魔道士","jobHistory": {"黒魔道士": 0},"accessories": []},
{"name": "ストーンゴーレム","level": 2,"hp": 80,"mp": 0,"exp": 50,"maxHp": 80,"maxMp": 0,"str": 24,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "ミミック","level": 3,"hp": 15,"mp": 0,"exp": 300,"maxHp": 15,"maxMp": 0,"str": 30,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "黒魔道士","jobHistory": {"黒魔道士": 0},"accessories": []},
{"name": "ドラゴン","level": 3,"hp": 70,"mp": 30,"exp": 80,"maxHp": 70,"maxMp": 30,"str": 28,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "白魔道士","jobHistory": {"白魔道士": 0},"accessories": []},
{"name": "ゴーレム","level": 3,"hp": 120,"mp": 0,"exp": 90,"maxHp": 120,"maxMp": 0,"str": 32,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "デスナイト","level": 3,"hp": 140,"mp": 0,"exp": 100,"maxHp": 140,"maxMp": 0,"str": 34,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "デモンナイト","level": 3,"hp": 112,"mp": 25,"exp": 120,"maxHp": 112,"maxMp": 25,"str": 30,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "黒魔道士","jobHistory": {"黒魔道士": 0},"accessories": []},
{"name": "アークデーモン","level": 3,"hp": 126,"mp": 0,"exp": 140,"maxHp": 126,"maxMp": 0,"str": 36,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "戦士","jobHistory": {"戦士": 0},"accessories": []},
{"name": "ハイドラ","level": 4,"hp": 200,"mp": 0,"exp": 160,"maxHp": 200,"maxMp": 0,"str": 40,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "バアル","level": 4,"hp": 154,"mp": 60,"exp": 180,"maxHp": 154,"maxMp": 60,"str": 38,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "僧侶","jobHistory": {"僧侶": 0},"accessories": []},
{"name": "ベリアル","level": 4,"hp": 210,"mp": 0,"exp": 300,"maxHp": 210,"maxMp": 0,"str": 42,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "戦士","jobHistory": {"戦士": 0},"accessories": []},
{"name": "アスモデウス","level": 5,"hp": 280,"mp": 150,"exp": 500,"maxHp": 280,"maxMp": 150,"str": 50,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "ルシファー","level": 5,"hp": 350,"mp": 200,"exp": 800,"maxHp": 350,"maxMp": 200,"str": 60,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "僧侶","jobHistory": {"僧侶": 0},"accessories": []},
{"name": "バフォメット","level": 5,"hp": 420,"mp": 250,"exp": 1000,"maxHp": 420,"maxMp": 250,"str": 65,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "ティアマト","level": 5,"hp": 490,"mp": 300,"exp": 1200,"maxHp": 490,"maxMp": 300,"str": 70,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "僧侶","jobHistory": {"僧侶": 0},"accessories": []},
{"name": "シヴァ","level": 5,"hp": 560,"mp": 350,"exp": 1500,"maxHp": 560,"maxMp": 350,"str": 75,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "黒魔道士","jobHistory": {"黒魔道士": 0},"accessories": []},
{"name": "ラミア","level": 5,"hp": 630,"mp": 400,"exp": 1800,"maxHp": 630,"maxMp": 400,"str": 80,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "白魔道士","jobHistory": {"白魔道士": 0},"accessories": []},
{"name": "ヴァルプルギス","level": 5,"hp": 700,"mp": 450,"exp": 2000,"maxHp": 700,"maxMp": 450,"str": 85,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "魔法使い","jobHistory": {"魔法使い": 0},"accessories": []},
{"name": "アヌビス","level": 5,"hp": 770,"mp": 500,"exp": 2200,"maxHp": 770,"maxMp": 500,"str": 90,"alive": true,"buffs": {"hp": 0,"mp": 0,"str": 0},"job": "僧侶","jobHistory": {"僧侶": 0},"accessories": []},
];
let heroes = [];
let enemies = [];

function initializeGame() {
    INITIAL_HEROES = INITIAL_HEROES.slice(0, INITIAL_HEROES_VOLUME); // 初期ヒーローの数だけスライス
    ENEMY_VOLUME_ARRAY = Array.from({ length: ENEMY_ARRAY_VOLUME }, (_, i) => (i + 1) * ENEMY_MORE_VOLUME + 1);    // ENEMY_MORE_VOLUMEが3でENEMY_ARRAY_VOLUMEが3ならENEMY_VOLUME_ARRAYは[1, 4, 7]になる
    ENEMY_LIST = ENEMY_LIST.map(e => test ? { ...e, hp: Math.floor(e.hp * HP_MULTIPLIER), exp: Math.floor(e.exp * EXP_MULTIPLIER) } : e);
    heroes = INITIAL_HEROES.map((hero) => {
        const [name, job] = hero;
        return createHero(name, job);
    });
    enemies = [];
}

let ITEM_LIST = [
    { id: 'tradeHpMpAll', name: '全員変換', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
    effect: (target, source) => {
        heroes.forEach(hero => {
            const tempHp = hero.hp;
            hero.hp = hero.mp;
            hero.mp = tempHp;
            logWrite(`${hero.name}のHPとMPが入れ替わった!!`);
        });
    } },
];

let INVENTORY = { // INVENTORYを定義（オブジェクト型、SPELLSと同じ構造で管理）
    tradeHpMpAll: { name: '全員変換', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
    effect: (target, source) => {
        console.log("INVENTORY tradeHpMpAll effect called");
        // 味方全員のHPとMPを入れ替えるスペル
        // target.forEach(hero => {
        heroes.forEach(hero => {
            const tempHp = hero.hp;
            hero.hp = hero.mp;
            hero.mp = tempHp;
            logWrite(`${hero.name}のHPとMPが入れ替わった!!`);
        });
    } },
};

// アクセサリのデータ構造
const ACCESSORY_LIST = [
    { name: '力の指輪', buff: 'str', value: 10, apply_type: 'add' },
    { name: '守りのペンダント', buff: 'hp', value: 20, apply_type: 'add' },
    { name: '魔力のイヤリング', buff: 'mp', value: 15, apply_type: 'add' },
    { name: '攻撃の腕輪', buff: 'str', value: 0.2, apply_type: 'multiply' },
    { name: '生命の指輪', buff: 'hp', value: 0.1, apply_type: 'multiply' },
];

// 戦闘終了時にアクセサリをドロップ
function dropAccessories(enemyCount) {
    const totalDropChance = enemyCount * (ACCESSORY_DROP_RATE / 100); // 敵の数に応じた期待値
    const dropCount = Math.floor(totalDropChance); // 確定ドロップ数
    const additionalDrop = Math.random() < (totalDropChance - dropCount) ? 1 : 0; // 端数分の確率で追加ドロップ
    const totalDrops = dropCount + additionalDrop;
    const droppedAccessories = [];
    for (let i = 0; i < totalDrops; i++) {
        const randomAccessory = ACCESSORY_LIST[rand(0, ACCESSORY_LIST.length - 1)];
        droppedAccessories.push(randomAccessory);
    }
    return droppedAccessories;
}

// アクセサリを装備する関数
function equipAccessory(hero, accessory) {
    if (!hero.accessories) {hero.accessories = []} // アクセサリの配列を初期化
    if (hero.accessories.length >= MAX_ACCESSORIES_PER_HERO) {
        logWrite(`${hero.name}はこれ以上アクセサリを装備できません。`);
        return;
    }
    hero.accessories.push(accessory);
    logWrite(`${hero.name}は「${accessory.name}」を装備しました！`);
}

function showAccessorySelection(droppedAccessories) { // 戦闘終了時にアクセサリを選択して装備
    console.log(droppedAccessories);
    actions.innerHTML = `<strong>ドロップしたアクセサリを装備してください:</strong>`;
    droppedAccessories.forEach((accessory, index) => {
        heroes.forEach((hero, heroIndex) => {
            const accessoryButton = document.createElement('button');
            accessoryButton.textContent = `${hero.name}に「${accessory.name}」を装備`;
            accessoryButton.onclick = () => {
                equipAccessory(hero, accessory);
                droppedAccessories.splice(index, 1); // ドロップリストから削除
                if (droppedAccessories.length === 0) {
                    logWrite('全てのアクセサリを装備しました。');
                    // ここで仲間化処理
                    const defeatedEnemies = enemies.filter(e => !e.alive);
                    convertEnemyToAlly(defeatedEnemies);
                } else {
                    showAccessorySelection(droppedAccessories); // 再描画
                }
            };
            actions.appendChild(accessoryButton);
        });
    });

    const skipButton = document.createElement('button');
    skipButton.textContent = '装備せず破棄';
    skipButton.onclick = () => {
        logWrite('装備しなかったアクセサリは破棄されました。');
        // ここで仲間化処理
        const defeatedEnemies = enemies.filter(e => !e.alive);
        convertEnemyToAlly(defeatedEnemies);
    };
    actions.appendChild(skipButton);
}

function startBattle(enemyCount = 2) { // 戦闘開始時に全キャラクターのアクセサリ効果を適用
    initializeGame();
    const clearLog = () => log.innerHTML = ''; // ログをクリアする関数
    clearLog();
    spawnEnemies(enemyCount);
    logWrite(`敵が${enemies.length}体あらわれた！（戦闘回数: ${battleCount}）`);
    updateEnemies();
    function applyAccessoryEffects(hero) { // 戦闘開始時にアクセサリの効果を適用
        if (hero.accessories) {
            hero.accessories.forEach(accessory => {
                applyBattleBuff(hero, accessory.buff, accessory.apply_type, accessory.value);
            });
        }
    }
    heroes.forEach(hero => applyAccessoryEffects(hero)); // アクセサリ効果を適用
    isEnemyTurn = false; // プレイヤーのターンから開始
    nextTurn();
}

function createHero(name, job) {
    const b = JOBS[job];
    return {
        name,
        job,
        level: 1,
        exp: 0,
        maxHp: b.hp,
        hp: b.hp,
        maxMp: b.mp,
        mp: b.mp,
        alive: true,
        jobHistory: { [job]: 1 },
        buffs: { hp: 0, mp: 0, str: 0 }, // 戦闘中の補正値
        get str() {
            return Math.floor(this.maxHp * STR_PERCENTAGE) + this.buffs.str;
        },
    };
}

function logWrite(msg) {
    log.innerHTML = `<div>${msg}</div>` + log.innerHTML; // 最新のメッセージを先頭に追加
    log.scrollTop = 0; // スクロールを一番上に設定
}

function allHeroesAttack() {
    heroes.filter(h => h.alive).forEach(hero => {
        const target = enemies.find(e => e.alive); // 最初の生存している敵をターゲット
        if (target) {
            actionsQueue.push({ hero, action: 'attack', target });
        }
    });
    executeHeroActions(); // 全員の攻撃を即時実行
}

function showHeroActionSelection() {
    if (currentHeroIndex >= heroes.length) {
        isEnemyTurn = true;
        executeHeroActions();
        return;
    }

    const hero = heroes[currentHeroIndex];
    if (!hero.alive) {
        currentHeroIndex++;
        showHeroActionSelection();
        return;
    }

    actions.innerHTML = `<strong>${hero.name}の行動を選択してください:</strong>`;
    const atkButton = document.createElement('button');
    atkButton.textContent = 'たたかう';

    atkButton.onclick = () => {showEnemySelectionForAttack(hero)};
    actions.appendChild(atkButton);

    if (test) {
        const allAtkButton = document.createElement('button');
        allAtkButton.textContent = '全員戦う';
        allAtkButton.onclick = () => {allHeroesAttack()};
        actions.appendChild(allAtkButton);
    } // 全員戦うボタンを追加 (testがtrueの時のみ表示)

    Object.entries(SPELLS).forEach(([key, sp]) => { // 通常スペルの表示
        if (hero.mp >= sp.cost) {
            const spellButton = document.createElement('button');
            spellButton.textContent = sp.name; // 日本語名を表示
            spellButton.onclick = () => {
                // ターゲット選択が必要な場合は選択UIを表示
                if (sp.range === 'single') {
                    let targets = [];
                        targets = [
                            ...heroes.filter(h => h.alive),
                            ...enemies.filter(e => e.alive)
                        ]; // buffやotherなどは味方も敵も選択肢に
                    actions.innerHTML = `<strong>対象を選択してください:</strong>`;
                    targets.forEach(target => {
                        const targetButton = document.createElement('button');
                        targetButton.textContent = target.name;
                        targetButton.onclick = () => {
                            actionsQueue.push({ hero, action: 'spell', spell: key, target });
                            currentHeroIndex++;
                            showHeroActionSelection();
                        };
                        actions.appendChild(targetButton);
                    });
                    const backButton = document.createElement('button');
                    backButton.textContent = '戻る'; // 戻るボタン
                    backButton.onclick = () => showHeroActionSelection();
                    actions.appendChild(backButton);
                }
                if (sp.range === 'all'|| sp.range === null) { // 範囲がallまたはnullの場合は全体魔法
                    // 全体魔法や特殊スペルは即実行
                    actionsQueue.push({ hero, action: 'spell', spell: key, target: null });
                    currentHeroIndex++;
                    showHeroActionSelection();
                }
            };
            actions.appendChild(spellButton);
        }
    });

    // 習得済みスペルの表示
    if (hero.learnedSpells && hero.learnedSpells.length > 0) {
        hero.learnedSpells.forEach(spellKey => {
            const sp = ULT_SPELLS[spellKey];
            if (hero.mp >= sp.cost) {
                const spellButton = document.createElement('button');
                spellButton.textContent = sp.name; // 日本語名を表示
                spellButton.onclick = () => {
                    if (sp.range === 'single' && !sp.effect) { // effectがある場合はtargetをnullにする
                        const targets = sp.type === 'heal'
                            ? heroes.filter(h => h.alive)
                            : enemies.filter(e => e.alive);
                        actions.innerHTML = `<strong>対象を選択してください:</strong>`;
                        targets.forEach(target => {
                            const targetButton = document.createElement('button');
                            targetButton.textContent = target.name;
                            targetButton.onclick = () => {
                                actionsQueue.push({ hero, action: 'spell', spell: spellKey, target });
                                currentHeroIndex++;
                                showHeroActionSelection();
                            };
                            actions.appendChild(targetButton);
                        });
                        const backButton = document.createElement('button');
                        backButton.textContent = '戻る'; // 戻るボタン
                        backButton.onclick = () => showHeroActionSelection();
                        actions.appendChild(backButton);
                    } else {
                        actionsQueue.push({ hero, action: 'spell', spell: spellKey, target: null });
                        currentHeroIndex++;
                        showHeroActionSelection();
                    }
                };
                actions.appendChild(spellButton);
            }
        });
    }

    if (Object.keys(INVENTORY).length > 0) {    // INVENTORYオブジェクトの数が0以上の時のみアイテムボタンを表示
        const itemButton = document.createElement('button');
        itemButton.textContent = 'アイテム';
        function showItemSelection(hero) {
            actions.innerHTML = `<strong>使用するアイテムを選択してください:</strong>`;

            Object.entries(INVENTORY).forEach(([itemKey, item]) => {
                const itemButton = document.createElement('button');
                itemButton.textContent = item.name;
                itemButton.onclick = () => useItem(hero, itemKey); // ← 修正: index→itemKey
                actions.appendChild(itemButton);
            });


            const backButton = document.createElement('button');
            backButton.textContent = '戻る';
            backButton.onclick = () => showHeroActionSelection();
            actions.appendChild(backButton);
        }
        itemButton.onclick = () => {showItemSelection(hero)};
        actions.appendChild(itemButton);
    }
}

function updateStats() {
    stats.innerHTML = heroes.map(hero => {
        const nextLevelExp = calculateExpForLevel(hero.level + 1) - hero.exp; // 次のレベルに必要な経験値を計算
        return `
            <div>
                ${hero.name} (${hero.job} Lv${hero.level}) 
                HP: ${hero.hp}/${hero.maxHp} 
                MP: ${hero.mp}/${hero.maxMp} 
                BUFF: ${JSON.stringify(hero.buffs.str)}
                EXP: ${hero.exp} 
                (次のLvまで: ${nextLevelExp > 0 ? nextLevelExp : 0})
            </div>
        `;
    }).join('');
}

function updateEnemies(){ 
    enemiesDiv.innerHTML=enemies.map(e=>`<div class="enemy ${!e.alive?'dead':''}" data-id="${e.id}">${e.name} HP:${e.hp}/${e.maxHp} MP:${e.mp}/${e.maxMp}</div>`).join('');
}

function spawnEnemies(count = 3) {
    enemies = [];
    const maxEnemyLevel = Math.max(...ENEMY_LIST.map(e => e.level));
    const minLevel = Math.min(Math.floor((battleCount - 1) / 2) + 1, maxEnemyLevel);
    const maxLevel = Math.min(minLevel + 1, maxEnemyLevel);

    let candidates = ENEMY_LIST.filter(e => e.level >= minLevel && e.level <= maxLevel); // 敵のレベルを調整
    if (candidates.length === 0) {
        candidates = ENEMY_LIST.filter(e => e.level === maxEnemyLevel);
    }

    for (let i = 0; i < count; i++) {
        const e = JSON.parse(JSON.stringify(candidates[rand(0, candidates.length - 1)]));

        e.id = i;
        enemies.push(e);
    }
}

function showBattleOptions() {
    actions.innerHTML = `
        <strong>次の戦闘を選択してください:</strong>
        ${ENEMY_VOLUME_ARRAY.map(volume => `<button onclick="startBattle(${volume})">敵${volume}体の戦闘</button>`).join('')}
    `;
    logWrite('次の戦闘の敵の数を選んでください。');
}

function visitInn() {    
    heroes = heroes.map(hero => {
        if (hero.alive) {
            return {
                ...hero,
                hp: hero.maxHp,
                mp: hero.maxMp
            };
        }
        return hero;
    });
    logWrite('宿屋で休んでHPとMPが全回復しました。');
    showBattleOptions(); // 次の戦闘選択肢を表示
}

function visitTemple() {
    function changeJob(heroIndex) {
        const hero = heroes[heroIndex];
        const availableJobs = Object.keys(JOBS).filter(job => job !== hero.job);
        actions.innerHTML = `<strong>${hero.name}の転職先を選んでください:</strong>`;
        availableJobs.forEach(job => {
            const jobButton = document.createElement('button');
            jobButton.textContent = job;
            jobButton.onclick = () => {
                function confirmChangeJob(heroIndex, newJob) {
                    const hero = heroes[heroIndex];
                    const oldJob = hero.job;
                    hero.jobHistory[oldJob] = hero.level; // 現在のジョブとレベルを履歴に保存
                    const oldStats = { maxHp: hero.maxHp, maxMp: hero.maxMp, }; // 転職処理
                    const newStats = JOBS[newJob];
                    hero.job = newJob;
                    hero.level = 1;
                    hero.exp = 0;
                    hero.maxHp = Math.floor(newStats.hp + oldStats.maxHp * STATUS_INHERITANCE_RATIO + rand(-2, 2));
                    hero.maxMp = Math.floor(newStats.mp + oldStats.maxMp * STATUS_INHERITANCE_RATIO + rand(-2, 2));
                    hero.hp = hero.maxHp;
                    hero.mp = hero.maxMp;

                    logWrite(`${hero.name}は${newJob}に転職しました！`);
                    actions.innerHTML = ''; // 転職後の選択肢を消す
                    showBattleOptions(); // 次の戦闘選択肢を表示
                }
                confirmChangeJob(heroIndex, job); // 転職を確定
            };
            actions.appendChild(jobButton);
        });
        const backButton = document.createElement('button');
        backButton.textContent = '戻る';
        backButton.onclick = visitTemple;
        actions.appendChild(backButton);
    }
    actions.innerHTML = heroes.map((hero, index) => `
      <div>
        <strong>${hero.name}</strong> (${hero.job} Lv${hero.level})
        <div>ジョブ履歴: ${Object.entries(hero.jobHistory || {}).map(([job, level]) => `${job}: Lv${level}`).join(', ') || 'なし'}</div>
        <button onclick="changeJob(${index})">転職する</button>
      </div>
    `).join('');
    logWrite('神殿で転職が可能です。');
    const backButton = document.createElement('button');
    backButton.textContent = '次の戦闘に進む';
    backButton.onclick = showBattleOptions; // 次の戦闘選択肢を表示
    actions.appendChild(backButton);
}

function visitTrainingGround() {
    actions.innerHTML = heroes.map((hero, index) => `
      <div>
        <strong>${hero.name}</strong> (${hero.job} Lv${hero.level})
        <div>ジョブ履歴: ${Object.entries(hero.jobHistory || {}).map(([job, level]) => `${job}: Lv${level}`).join(', ') || 'なし'}</div>
        <button onclick="showSkillOptions(${index})">スキルを習得する</button>
      </div>
    `).join('');
    logWrite('修行場でスキルを習得できます。');
    const backButton = document.createElement('button');
    backButton.textContent = '次の戦闘に進む';
    backButton.onclick = showBattleOptions; // 次の戦闘選択肢を表示
    actions.appendChild(backButton);
}

let currentHeroIndex = 0; // 現在行動を選択中の味方のインデックス
let actionsQueue = []; // 味方の行動キュー
let isEnemyTurn = false; // 現在のターンが敵かどうか
let battleCount = 1; // 戦闘回数を初期化

function allHeroesAttack() {
    heroes.filter(h => h.alive).forEach(hero => {
        const target = enemies.find(e => e.alive); // 最初の生存している敵をターゲット
        if (target) {
            actionsQueue.push({ hero, action: 'attack', target });
        }
    });
    executeHeroActions(); // 全員の攻撃を即時実行
}

function nextTurn() {
    updateStats();
    updateEnemies();
    actions.innerHTML = '';

    if (!heroes.some(h => h.alive)) {
      logWrite('全滅…ゲームオーバー');
      return;
    }

    if (!enemies.some(e => e.alive)) {
      giveExp();
      return;
    }

    if (isEnemyTurn) {
      enemyTurn();
    } else {
      currentHeroIndex = 0;
      actionsQueue = [];
      showHeroActionSelection();
    }
}

function showEnemySelectionForAttack(hero) {
    actions.innerHTML = `<strong>攻撃する敵を選んでください:</strong>`;
    enemies
        .filter(e => e.alive)
        .forEach(enemy => {
        const enemyButton = document.createElement('button');
        enemyButton.textContent = enemy.name;
        enemyButton.onclick = () => {
            actionsQueue.push({ hero, action: 'attack', target: enemy });
            currentHeroIndex++;
            showHeroActionSelection();
        };
        actions.appendChild(enemyButton);
        });
}

function selectEnemyTarget() {
    const aliveEnemies = enemies.filter(e => e.alive);
    if (aliveEnemies.length === 0) return null;
    const target = aliveEnemies[0]; // 最初の敵を選択（ランダムではなく順番に） 
    logWrite(`ターゲット: ${target.name}`);
    return target;
}

function selectHeroTarget() {
    const aliveHeroes = heroes.filter(h => h.alive);
    if (aliveHeroes.length === 0) return null;
    const target = aliveHeroes[0]; // 最初の味方を選択（ランダムではなく順番に）
    logWrite(`ターゲット: ${target.name}`);
    return target;
}

function executeHeroActions() {
    while (actionsQueue.length > 0) {
        const { hero, action, spell, target } = actionsQueue.shift();
        if (action === 'attack') { // strにbuffを加味したダメージ計算
            const baseStr = Math.floor(hero.maxHp * STR_PERCENTAGE);
            const totalStr = baseStr + hero.buffs.str; // buffs.strを加算
            const dmg = rand(totalStr, totalStr + 6); // strを基にダメージ計算
            target.hp -= dmg;
            logWrite(`${hero.name}の攻撃！${target.name}に${dmg}ダメージ！`);
            if (target.hp <= 0) {
                target.alive = false;
                target.hp = 0;
                logWrite(`${target.name}を倒した！`);
            }
        } 
        if (action === 'spell') {
            castSpell(hero, spell, target);
        }
    }
    nextTurn(); // 敵のターンへ
}

function castSpell(hero, spell, target) {
    const sp = SPELLS[spell] || ULT_SPELLS[spell];
    if (!sp) {
        logWrite(`${spell}は存在しないスペルです。`);
        return;
    }

    hero.mp -= sp.cost;

    if (sp.type === 'buff') {
        const buffTarget = sp.range === 'all' ? heroes.filter(h => h.alive) : [target];
        sp.effect(buffTarget, hero);
        return;
    }

    // effectプロパティがあれば必ずそれを実行し、他の処理は行わない
    if (sp.type === 'other') {
        console.log(target, hero);
        (typeof sp.effect === 'function') ? sp.effect(target, hero) : logWrite(`${spell}の効果を実行できませんでした。`);
        return;
    }

    // sp.type summonの場合の処理
    if (sp.type === 'summon') {
        // sp.effectを実行
        sp.effect(target=null, hero);
        return;
    }
    

    switch (true) {
        case sp.range === 'all':
            (sp.type === 'heal' ? heroes.filter(h => h.alive) : enemies.filter(e => e.alive))
                .forEach(t => applySpellEffect(hero, spell, sp, t));
            break;
        case sp.type === 'heal':
            const healTarget = heroes.filter(h => h.alive).sort((a, b) => a.hp - b.hp)[0];
            healTarget && applySpellEffect(hero, spell, sp, healTarget);
            break;
        case sp.type === 'dmg':
            const dmgTarget = enemies.filter(e => e.alive).sort((a, b) => a.hp - b.hp)[0];
            dmgTarget && applySpellEffect(hero, spell, sp, dmgTarget);
            break;
        case sp.type === 'debuff':
            const debuffTarget = enemies.filter(e => e.alive).sort((a, b) => b.hp - a.hp)[0];
            debuffTarget && applySpellEffect(hero, spell, sp, debuffTarget);
            break;
        default:
            applySpellEffect(hero, spell, sp, target);
    }
}

function applySpellEffect(hero, spellName, sp, target) {
    if (sp.type === 'heal') {
        const healAmount = rand(...sp.val);
        target.hp = Math.min(target.maxHp, target.hp + healAmount);
        logWrite(`${hero.name}は${spellName}を唱えた！${target.name}のHPが${healAmount}回復した！`);
    } 
    if (sp.type === 'dmg') {
        const dmg = rand(...sp.val); // スペルのダメージをそのまま使用
        target.hp -= dmg;
        logWrite(`${hero.name}は${spellName}を唱えた！${target.name}に${dmg}ダメージ！`);
        if (target.hp <= 0) {
            target.alive = false;
            target.hp = 0;
            logWrite(`${target.name}を倒した！`);
        }
    }
}

function enemyTurn() {
    const aliveHeroes = heroes.filter(h => h.alive);
    if (aliveHeroes.length === 0) {
        logWrite('全滅…ゲームオーバー');
        return;
    }

    enemies.filter(e => e.alive).forEach(e => {
        const actionChance = Math.random();
        const target = heroes.filter(h => h.alive)[rand(0, heroes.filter(h => h.alive).length - 1)];
        const attack = () => {
            const dmg = rand(5, 15);
            target.hp -= dmg;
            target.hp <= 0
                ? (target.alive = false, target.hp = 0, logWrite(`${e.name}の攻撃！${target.name}は倒れた…`))
                : logWrite(`${e.name}の攻撃！${target.name}に${dmg}ダメージ！`);
        };
        const castSpell = () => {
            const dmgSpells = Object.entries(SPELLS).filter(([_, sp]) => sp.type === 'dmg' && e.mp >= sp.cost);
            if (dmgSpells.length > 0) {
                const [spellName, spell] = dmgSpells[rand(0, dmgSpells.length - 1)];
                e.mp -= spell.cost;
                const dmg = rand(...spell.val);
                target.hp -= dmg;
                target.hp <= 0
                    ? (target.alive = false, target.hp = 0, logWrite(`${e.name}は${spellName}を唱えた！${target.name}は倒れた…`))
                    : logWrite(`${e.name}は${spellName}を唱えた！${target.name}に${dmg}ダメージ！`);
            } else {
                logWrite(`${e.name}はMPが足りないため、何もしなかった…`);
            }
        };
        e.mp === 0
            ? attack()
            : actionChance < 0.1
                ? logWrite(`${e.name}は様子を見ている…`)
                : actionChance < 0.7
                    ? attack()
                    : castSpell();
    });

    isEnemyTurn = false; // 敵のターンが終わったら味方のターンに移行
    nextTurn();
}

const showGameOverScreen = () => {actions.innerHTML = `<button onclick="location.reload()">リスタート</button>`; logWrite('<strong>全滅…ゲームオーバー</strong>')};

function visitInn() {
    heroes = heroes.map(hero => {
        if (hero.alive) { // 生存しているキャラクターのみ回復
            return {
                ...hero,
                hp: hero.maxHp, // HPを最大値まで回復
                mp: hero.maxMp, // MPを最大値まで回復
                exp: 0 // 経験値をリセット
            };
        }
        return hero; // 死亡しているキャラクターはそのまま
    });
    logWrite('宿屋で休んでHPとMPが全回復しました!（経験値がリセットされました）');
    startBattle(); // 次の戦闘へ
}

const calculateExpForLevel = (level) => Math.floor(50 * Math.pow(1.5, level - 1)); // レベルアップに必要な経験値を計算

function giveExp() {
    function resetBuffs() {
        heroes.forEach(hero => {hero.buffs = { hp: 0, mp: 0, str: 0 }});
        enemies.forEach(enemy => {enemy.buffs = { hp: 0, mp: 0, str: 0 }});
    }
    resetBuffs();
    const clearLog = () => log.innerHTML = ''; // ログをクリアする関数
    clearLog();
    logWrite('敵を全滅させた！経験値を獲得！');
    let totalExp = enemies.reduce((sum, e) => sum + (e.alive ? 0 : e.exp), 0); // 倒した敵の経験値を合計
    let sharedExp = Math.floor(totalExp / heroes.length); // パーティ全員で等分
    heroes.forEach(hero => {
        if (!hero.alive) return; // 死亡しているキャラクターはスキップ
        hero.mp = hero.maxMp < hero.mp ? hero.maxMp : hero.mp; // 最大値を超えたMPを最大値に切り捨て(最大MPを超えてMPをチャージするスペルが存在するため)
        hero.exp += sharedExp; // 経験値を加算
        logWrite(`${hero.name}は${sharedExp}の経験値を得た！（現在の経験値: ${hero.exp}）`);
        while (hero.exp >= calculateExpForLevel(hero.level)) {
            hero.exp -= calculateExpForLevel(hero.level); // 現在のレベルに必要な経験値を差し引く
            hero.level++; // レベルアップ
            const growth = JOB_GROWTH[hero.job];
            hero.maxHp += rand(...growth.maxHp); // HP増加
            hero.maxMp += rand(...growth.maxMp); // MP増加
            hero.hp = hero.maxHp; // HPを全回復
            hero.mp = hero.maxMp; // MPを全回復
            hero.jobHistory[hero.job] = Math.max(hero.jobHistory[hero.job] || 0, hero.level); // ジョブ履歴を更新
            logWrite(`${hero.name}はLv${hero.level}に上がった！`);
        }
    });



    const droppedAccessories = dropAccessories(enemies.length); // アクセサリをドロップ
    console.log(droppedAccessories);
    droppedAccessories.length > 0 ? showAccessorySelection(droppedAccessories) : accessories_fn(); // アクセサリがドロップされた場合は選択画面を表示

}

function dropItems(enemyCount) { // 敵の数かけるVOLUME_DROPSのdrop
    const dropCount = enemyCount === 1 ? 1 : enemyCount * VOLUME_DROPS;
    for (let i = 0; i < dropCount; i++) {
        const randomItem = ITEM_LIST[rand(0, ITEM_LIST.length - 1)];
        INVENTORY.push(randomItem); // インベントリに追加
        logWrite(`アイテム「${randomItem.name}」を入手しました！`);
    }
}

function useItem(hero, spellKey) {
    const spell = INVENTORY[spellKey];
    if (!spell) return;
    if (spell.range === null) {
        spell.effect(null, hero); // 範囲がnullの場合はターゲットなしで実行
    }
    if (spell.range === 'all') {
        spell.effect(target = null, hero);
    } 
    if (spell.range === 'single') {
        actions.innerHTML = `<strong>対象を選択してください:</strong>`;
        let targets = []; // 単体対象はUIで選択
        targets.forEach(target => {
            const btn = document.createElement('button');
            btn.textContent = target.name;
            btn.onclick = () => {
                spell.effect(target, hero);
                delete INVENTORY[spellKey];
                showHeroActionSelection();
            };
            actions.appendChild(btn);
        });
        const backButton = document.createElement('button');
        backButton.textContent = '戻る';            // 戻るボタン
        backButton.onclick = () => showHeroActionSelection();
        actions.appendChild(backButton);
        return;
    }
    delete INVENTORY[spellKey];
    showHeroActionSelection();
    updateStats();updateEnemies();
} // useItem: INVENTORYからスペルを1回使って消費する関数

function showTargetSelection(hero, item, itemIndex) {
    actions.innerHTML = `<strong>対象を選択してください:</strong>`;
    const targets = item.type === 'heal' ? heroes.filter(h => h.alive) : heroes.filter(h => h.alive);

    targets.forEach(target => {
        const targetButton = document.createElement('button');
        targetButton.textContent = target.name;
        targetButton.onclick = () => {
            const amount = rand(...item.val);
            if (item.type === 'heal') {
                target.hp = Math.min(target.maxHp, target.hp + amount);
                logWrite(`${hero.name}は「${item.name}」を使った！${target.name}のHPが${amount}回復した！`);
            }
            if (item.type === 'mp') {
                target.mp = Math.min(target.maxMp, target.mp + amount);
                logWrite(`${hero.name}は「${item.name}」を使った！${target.name}のMPが${amount}回復した！`);
            }
            INVENTORY.splice(itemIndex, 1); // アイテムを消費
            showHeroActionSelection(); // 次の行動選択へ
        };
        actions.appendChild(targetButton);
    });

    const backButton = document.createElement('button');
    backButton.textContent = '戻る';
    backButton.onclick = () => showHeroActionSelection();
    actions.appendChild(backButton);
}

function showEnding() {
    actions.innerHTML = `
      <h2>エンディング</h2>
      <p>勇者たちはすべての敵を倒し、世界に平和を取り戻しました。</p>
      <button onclick="location.reload()">もう一度プレイする</button>`;
    logWrite('<strong>ゲームクリア！おめでとうございます！</strong>');
}

function visitTrainingGround() {
    function showSkillOptions(heroIndex) {
        const hero = heroes[heroIndex]; // 1行関数で条件判定を分離
        const hasJobLevel = (job, lv) => (hero.jobHistory[job] || 0) >= lv;
        const canLearnSkill = ([, details]) =>
            Object.entries(details.requiredJobs).every(([job, lv]) => hasJobLevel(job, lv)); // スキル習得条件を満たすか判定
        const isSkillLearned = (spell) => hero.learnedSpells && hero.learnedSpells.includes(spell); // 既に習得済みか判定
        const availableSkills = Object.entries(ULT_SPELLS).filter(([spell, details]) => canLearnSkill([spell, details]) && !isSkillLearned(spell)); // 習得可能なスキルをフィルタリング
        if (availableSkills.length === 0) {logWrite(`${hero.name}は習得可能なスキルがありません。`); return; } // 習得可能なスキルがない場合はメッセージを表示

        function learnSkill(heroIndex, spell) {
            const hero = heroes[heroIndex];
            hero.learnedSpells = hero.learnedSpells || [];
            hero.learnedSpells.push(spell);
            logWrite(`${hero.name}は「${spell}」を習得しました！`);
            showBattleOptions();    // 戦闘選択肢に戻る    
        }
        
        actions.innerHTML = availableSkills.map(([spell, details]) => `
        <div>
            <strong>${details.name}</strong> (${details.type === 'dmg' ? '攻撃' : '回復'}) - MP: ${details.cost}
            <button onclick="learnSkill(${heroIndex}, '${spell}')">習得する</button>
        </div>
        `).join('');
    }

    actions.innerHTML = heroes.map((hero, index) => `
      <div>
        <strong>${hero.name}</strong> (${hero.job} Lv${hero.level})
        <div>ジョブ履歴: ${Object.entries(hero.jobHistory || {}).map(([job, level]) => `${job}: Lv${level}`).join(', ') || 'なし'}</div>
        <button onclick="showSkillOptions(${index})">スキルを習得する</button>
      </div>
    `).join('');

    logWrite('修行場でスキルを習得できます。');
    const backButton = document.createElement('button');
    backButton.textContent = '次の戦闘に進む';
    backButton.onclick = showBattleOptions; // 次の戦闘選択肢を表示
    actions.appendChild(backButton);
}

function showInnOrTemple() {
    updateStats(); // ステータスを画面に反映
    battleCount++; // 戦闘回数を増加
    actions.innerHTML = `
      <button onclick="visitInn()">宿屋に行く</button>
      <button onclick="visitTemple()">神殿に行く</button>
      <button onclick="visitTrainingGround()">修行場に行く</button>
      <button onclick="showBattleOptions()">次の戦闘に行く</button>`;
    logWrite('宿屋、神殿、修行場のいずれかを選んでください。または次の戦闘に進むこともできます。');
}

function addAlly(enemyName) {
    const defeatedEnemy = enemies.find(e => e.name === enemyName);
    if (!defeatedEnemy) return;
    function become_hero_from_enemy(enemy) {
        return {
            // job, level, jobHistory, accessoriesは敵のENEMY_LISTから流用
            name: enemy.name,
            job: ENEMY_LIST.find(e => e.name === enemy.name).job, // 敵のジョブを取得
            jobHistory: ENEMY_LIST.find(e => e.name === enemy.name).jobHistory || {}, // ジョブ履歴を敵のものから取得
            accessories: ENEMY_LIST.find(e => e.name === enemy.name).accessories || [], // アクセサリを敵のものから取得
            hp: enemy.hp,
            maxHp: enemy.maxHp,
            mp: enemy.mp,
            maxMp: enemy.maxMp,
            level: ENEMY_LIST.find(e => e.name === enemy.name).level, // 敵のレベルを取得
            exp: 0, // 初期経験値は0
            buffs: { hp: 0, mp: 0, str: 0 }, // バフの初期化
            alive: true, // 生存状態
            jobHistory: ENEMY_LIST.find(e => e.name === enemy.name).jobHistory || {}, // ジョブ履歴を敵のものから取得
        };
    }
    const hero = become_hero_from_enemy(defeatedEnemy); // 敵を仲間にする
    hero.hp = hero.maxHp; // HPを全回復
    hero.mp = hero.maxMp; // MPを全回復
    heroes.push(hero);
    logWrite(`${defeatedEnemy.name}が味方になりました！`);
    actions.innerHTML = ''; // 選択画面を消す
    showInnOrTemple(); // 次の行動選択画面を表示
}

function rejectAlly(enemyName) {
    logWrite(`${enemyName}を仲間にするのを断りました。`);
    actions.innerHTML = ''; // 選択画面を消す
    showInnOrTemple(); // 次の行動選択画面を表示
}

function convertEnemyToAlly(defeatedEnemies) {
    if (heroes.length >= MAX_HEROES) {
        logWrite('味方の人数が最大です。これ以上仲間にできません。');
        showInnOrTemple(); // 仲間にできない場合は宿屋や神殿の選択肢を表示
        return;
    }
    if (!defeatedEnemies || defeatedEnemies.length === 0) {
        showInnOrTemple();
        return;
    }
    const is_be_friend = () => Math.random() * 100 < ENEMY_FRIENDLY_PER; // 敵が仲間になりたがっている確率
    if (is_be_friend()) {
        const newAlly = defeatedEnemies[rand(0, defeatedEnemies.length - 1)];
        actions.innerHTML = `
            <div>
                <strong>${newAlly.name}が味方になりたそうにこちらを見ている…</strong>
                <button onclick="addAlly('${newAlly.name}')">仲間にする</button>
                <button onclick="rejectAlly('${newAlly.name}')">断る</button>
            </div>
            `; // 選択画面を表示
    }else{
        showInnOrTemple(); // 仲間にできない場合は宿屋や神殿の選択肢を表示
    }
}

function applyBattleBuff(hero, stat, apply_type='add', value) {
    if (hero.buffs[stat] == undefined) {
        logWrite(`無効なステータス: ${stat}`);
        return;
    }
    if (apply_type === 'add') {
        hero.buffs[stat] += value;
        logWrite(`${hero.name}の${stat}が${value > 0 ? '+' : ''}${value}されました！`);
    } 
    if (apply_type === 'multiply') {
        hero.buffs[stat] += Math.floor(hero[stat] + hero.buffs[stat]) * value;
        logWrite(`${hero.name}の${hero[stat]}が${Math.floor(hero[stat] + hero.buffs[stat]) * value}${value}されました！`);
    }
}

startBattle();
</script>
</body>
</html>