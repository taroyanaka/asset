<!DOCTYPE html>
7
<html lang="ja">
<script>
// let test = true; // テストモードのフラグ
const test = false;
</script>
<head>
  <meta charset="UTF-8">
  <title>ターンバトル</title>
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: sans-serif;
      padding: 20px;
      display: flex; /* フレックスボックスでレイアウト */
    }
    .left-column {
      width: 30%; /* 左カラムの幅 */
      margin-right: 10px;
    }
    .right-column {
      width: 70%; /* 右カラムの幅 */
      display: flex;
      flex-direction: column;
    }
    .log {
      height: 90vh;
      overflow-y: auto;
      border: 1px solid #0f0;
      padding: 10px;
    }
    .stats, .actions, .enemies {
      margin-bottom: 10px;
      border: 1px solid #0f0;
      padding: 10px;
    }
    button {
      margin: 2px;
    }
    .enemy {
      display: inline-block;
      border: 1px solid #0f0;
      padding: 5px;
      margin: 2px;
    }
    .dead {
      opacity: 0.5;
    }
    /* ボタンを全て2倍の大きさにする */
    button {
      font-size: 2em;
      padding: 10px 20px;
      margin: 5px;
      background-color: #0f0;
      color: #000;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

  </style>
</head>
<body>
  <div class="left-column">
    <div class="log" id="log"></div>
  </div>
  <div class="right-column">
    <div class="stats" id="stats"></div>
    <div class="enemies" id="enemies"></div>
    <div class="actions" id="actions"></div>
  </div>

<script>
let seed = 45;
function rand(min, max) {
    seed = (seed * 9301 + 49297) % 233280;
    return Math.floor(seed / 233280 * (max - min + 1)) + min;
}
const HP_MULTIPLIER = test ? 0.1 : 1; // HP倍率 test===trueの時はhpを0.1倍でexpを100倍(1行で)
const EXP_MULTIPLIER = test ? 100 : 1; // 経験値倍率 test===trueの時はhpを0.1倍でexpを100倍(1行で)
const INITIAL_HEROES_VOLUME = 1; // 初期ヒーローの数
// 初期のヒーローの名前と職業を決めるテーブル
let INITIAL_HEROES = [
    // ['サトウ', '戦士'],
    ['スズキ', '魔法使い'],
    ['タナカ', '僧侶'],
];

INITIAL_HEROES = INITIAL_HEROES.slice(0, INITIAL_HEROES_VOLUME); // 初期ヒーローの数だけスライス

const ENEMY_VOLUME_ARRAY = [1, 4, 8]; // 敵の出現数の配列
const MAX_HEROES = 7; // 最大ヒーロー数
const VOLUME_DROPS = 1; // 敵2体でVOLUME_DROPSが1ならdrop数は2
const STR_PERCENTAGE = 0.4; // ステータスの割合    
const STATUS_INHERITANCE_RATIO = 0.4; // 前職から引き継ぐステータスの割合
const ENEMY_FRIENDLY_PER = test ? 100 : 50;
// アクセサリのドロップ確率（1体あたりのドロップ確率をパーセンテージで設定）
const ACCESSORY_DROP_RATE = 90; // 90%の確率で1体あたりドロップ
// 1キャラ当たりの最大装備数
const MAX_ACCESSORIES_PER_HERO = 1; // 1キャラ当たりの最大装備数

const log = document.getElementById('log');
const stats = document.getElementById('stats');
const enemiesDiv = document.getElementById('enemies');
const actions = document.getElementById('actions');


const JOBS = {
    戦士: { hp: 80, mp: 0 },
    僧侶: { hp: 60, mp: 20 },
    魔法使い: { hp: 50, mp: 30 },
    黒魔道士: { hp: 40, mp: 40 },
    白魔道士: { hp: 50, mp: 30 },
};

const JOB_GROWTH = {
    戦士: { maxHp: [5, 10], maxMp: [0, 0] },
    僧侶: { maxHp: [3, 6], maxMp: [3, 6] },
    魔法使い: { maxHp: [2, 5], maxMp: [4, 8] },
    黒魔道士: { maxHp: [0, 0], maxMp: [7, 12] },
    白魔道士: { maxHp: [0, 0], maxMp: [6, 10] },
};
// ゲームのテンポのために初期レベル帯のエネミーの経験値は高く設定
let ENEMY_LIST = [
// {name: 'スライム', level: 1, hp: 30, mp: 0, exp: 50, maxHp: 80, maxMp: 0, str: 12, int: 2},
{name: 'スライム', level: 1, hp: 30, mp: 20, exp: 50, maxHp: 80, maxMp: 20, str: 12, int: 2},
// {name: 'バンシー', level: 1, hp: 25, mp: 10, exp: 60, maxHp: 25, maxMp: 10, str: 8, int: 6},
{name: 'バンシー', level: 1, hp: 25, mp: 40, exp: 60, maxHp: 25, maxMp: 40, str: 8, int: 6},

{name: 'コボルト', level: 1, hp: 20, mp: 0, exp: 90, maxHp: 20, maxMp: 0, str: 10, int: 4},
{name: 'ゴブリン', level: 2, hp: 40, mp: 0, exp: 90, maxHp: 40, maxMp: 0, str: 12, int: 5},
{name: 'バジリスク', level: 2, hp: 35, mp: 5, exp: 100, maxHp: 35, maxMp: 5, str: 14, int: 7},
{name: 'ケルベロス', level: 2, hp: 30, mp: 0, exp: 110, maxHp: 30, maxMp: 0, str: 16, int: 6},
{name: 'サイクロプス', level: 3, hp: 60, mp: 0, exp: 30, maxHp: 60, maxMp: 0, str: 18, int: 8},
{name: 'リッチ', level: 3, hp: 50, mp: 0, exp: 28, maxHp: 50, maxMp: 0, str: 14, int: 12},
{name: 'ウォーロック', level: 3, hp: 31, mp: 20, exp: 32, maxHp: 31, maxMp: 20, str: 10, int: 14},
{name: 'キメラ', level: 4, hp: 49, mp: 15, exp: 40, maxHp: 49, maxMp: 15, str: 20, int: 10},
{name: 'タロス', level: 4, hp: 65, mp: 0, exp: 44, maxHp: 65, maxMp: 0, str: 22, int: 8},
{name: 'ストーンゴーレム', level: 4, hp: 80, mp: 0, exp: 50, maxHp: 80, maxMp: 0, str: 24, int: 6},
{name: 'ミミック', level: 5, hp: 15, mp: 0, exp: 300, maxHp: 15, maxMp: 0, str: 30, int: 20},
{name: 'ドラゴン', level: 5, hp: 70, mp: 30, exp: 80, maxHp: 70, maxMp: 30, str: 28, int: 18},
{name: 'ゴーレム', level: 5, hp: 120, mp: 0, exp: 90, maxHp: 120, maxMp: 0, str: 32, int: 10},
{name: 'デスナイト', level: 6, hp: 140, mp: 0, exp: 100, maxHp: 140, maxMp: 0, str: 34, int: 12},
{name: 'デモンナイト', level: 6, hp: 112, mp: 25, exp: 120, maxHp: 112, maxMp: 25, str: 30, int: 16},
{name: 'アークデーモン', level: 6, hp: 126, mp: 50, exp: 140, maxHp: 126, maxMp: 50, str: 36, int: 20},
{name: 'ハイドラ', level: 7, hp: 200, mp: 0, exp: 160, maxHp: 200, maxMp: 0, str: 40, int: 14},
{name: 'バアル', level: 7, hp: 154, mp: 60, exp: 180, maxHp: 154, maxMp: 60, str: 38, int: 22},
{name: 'ベリアル', level: 8, hp: 210, mp: 100, exp: 300, maxHp: 210, maxMp: 100, str: 42, int: 28},
{name: 'アスモデウス', level: 9, hp: 280, mp: 150, exp: 500, maxHp: 280, maxMp: 150, str: 50, int: 30},
{name: 'ルシファー', level: 10, hp: 350, mp: 200, exp: 800, maxHp: 350, maxMp: 200, str: 60, int: 40},
{name: 'バフォメット', level: 10, hp: 420, mp: 250, exp: 1000, maxHp: 420, maxMp: 250, str: 65, int: 45},
{name: 'ティアマト', level: 10, hp: 490, mp: 300, exp: 1200, maxHp: 490, maxMp: 300, str: 70, int: 50},
{name: 'シヴァ', level: 10, hp: 560, mp: 350, exp: 1500, maxHp: 560, maxMp: 350, str: 75, int: 55},
{name: 'ラミア', level: 10, hp: 630, mp: 400, exp: 1800, maxHp: 630, maxMp: 400, str: 80, int: 60},
{name: 'ヴァルプルギス', level: 10, hp: 700, mp: 450, exp: 2000, maxHp: 700, maxMp: 450, str: 85, int: 65},
{name: 'アヌビス', level: 10, hp: 770, mp: 500, exp: 2200, maxHp: 770, maxMp: 500, str: 90, int: 70},
];

let heroes = [];
let enemies = [];

function initializeGame() {
    ENEMY_LIST = ENEMY_LIST.map(e => test ? { ...e, hp: Math.floor(e.hp * HP_MULTIPLIER), exp: Math.floor(e.exp * EXP_MULTIPLIER) } : e);
    heroes = INITIAL_HEROES.map((hero) => {
        const [name, job] = hero;
        return createHero(name, job);
    });
    enemies = [];
}
initializeGame();



let ITEM_LIST = [
    // itemは現在はhealのみに対応
    { name: 'やくそう1', type: 'heal', range: 'single', val: [20, 30], cost: 0 },
    { name: 'やくそう2', type: 'heal', range: 'single', val: [30, 50], cost: 0 },
    // { name: 'やくそう3', type: 'heal', range: 'single', val: [50, 70], cost: 0 },
    { name: 'やくそう4', type: 'heal', range: 'single', val: [70, 100], cost: 0 },
    { name: 'やくそう5', type: 'heal', range: 'single', val: [100, 150], cost: 0 },
    // 効果範囲全員を少量回復するitem
    // { name: '全員やくそう1', type: 'heal', range: 'all', val: [10, 20], cost: 0 },
    { name: '全員やくそう2', type: 'heal', range: 'all', val: [20, 30], cost: 0 },
    { name: '全員やくそう3', type: 'heal', range: 'all', val: [30, 50], cost: 0 },
    // { name: '全員やくそう4', type: 'heal', range: 'all', val: [50, 70], cost: 0 },


// mp回復itemを実装
    { name: 'まほうのせいすい1', type: 'mp', range: 'single', val: [20, 30], cost: 0 },
    // { name: 'まほうのせいすい2', type: 'mp', range: 'single', val: [30, 50], cost: 0 },
    // { name: 'まほうのせいすい3', type: 'mp', range: 'single', val: [50, 70], cost: 0 },
    // { name: 'まほうのせいすい4', type: 'mp', range: 'single', val: [70, 100], cost: 0 },
    { name: 'まほうのせいすい5', type: 'mp', range: 'single', val: [100, 150], cost: 0 },
    // 効果範囲全員を少量回復するitem
    { name: '全員まほうのせいすい1', type: 'mp', range: 'all', val: [10, 20], cost: 0 },
    // { name: '全員まほうのせいすい2', type: 'mp', range: 'all', val: [20, 30], cost: 0 },
    // { name: '全員まほうのせいすい3', type: 'mp', range: 'all', val: [30, 50], cost: 0 },
    { name: '全員まほうのせいすい4', type: 'mp', range: 'all', val: [50, 70], cost: 0 },

];
 // 所持アイテムリスト
let inventory = [
    { name: 'やくそう1', type: 'heal', range: 'single', val: [20, 30], cost: 0 },
    { name: '力の種', type: 'buff', range: 'single', buff: 'str', val: [10, 20], cost: 0, apply_type: 'add'},
    { name: 'すごい力の種', type: 'buff', range: 'single', buff: 'str', val: [20, 30], cost: 0, apply_type: 'multiply'},
];

// SPELLの実装方針としてHP回復系は実装しない(別ゲーで敵/味方問わず戦闘中の回復がゲーム体験に悪影響と感じたため)
// 味方のHP回復系はアイテムで実装して短期決戦を促す
// 同様の理由でdebuff系も実装しない
// SPELLの数は100を目処として実装する(一通り実装してからゲーム体験が悪くなるものをコメントアウトしていく)
// スペル中心のゲームになるだろうからスペル全般テストコード必要
// コードの行数が多くなるので、スペルの実装は別ファイルに分けるかも
const SPELLS = {
    // chiyu: { name: '治癒', cost: 5, type: 'heal', range: 'single', val: [20, 30], requiredJobs: { 僧侶: 1 } },
    itami: { name: '痛み', cost: 4, type: 'dmg', range: 'single', val: [20, 30], requiredJobs: { 魔法使い: 1 } },
        // 追加の特殊スペル(未テスト)
    tradeHpMp: { name: '変換', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const tempHp = target.hp;target.hp = target.mp;target.mp = tempHp;logWrite(`${target.name}のHPとMPが入れ替わった!!`) } },




    // 味方全員のHPとMPを入れ替えるスペル
    tradeHpMpAll: { name: '全員変換', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const tempHp = target.hp;target.hp = target.mp;target.mp = tempHp;logWrite(`${target.name}のHPとMPが入れ替わった!!`) } },

    // 敵単体のMPを自分のMPと入れ替えるスペル
    tradeMp: { name: 'MP変換', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const tempMp = target.mp;target.mp = source.mp;source.mp = tempMp;logWrite(`${source.name}は${target.name}のMPと入れ替えた!!`) } },
    // 敵単体の最大MPを自分のMPと入れ替えるスペル
    tradeMaxMp: { name: '最大MP変換', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const tempMp = target.maxMp;target.maxMp = source.mp;source.mp = tempMp;logWrite(`${source.name}は${target.name}の最大MPと入れ替えた!!`) } },
    // 敵全体のMPの累計を自分のMPにするスペル
    tradeMpAll: { name: '全員MP変換', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const totalMp = target.reduce((sum, enemy) => sum + enemy.mp, 0);source.mp += totalMp;logWrite(`${source.name}は${target.map(e => e.name).join(',')}のMPを合計(${totalMp})分吸収した!!`) } },
    // 敵全体の最大MPの累計を自分のMPにするスペル
    tradeMaxMpAll: { name: '全員最大MP変換', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const totalMaxMp = target.reduce((sum, enemy) => sum + enemy.maxMp, 0);source.mp += totalMaxMp;logWrite(`${source.name}は${target.map(e => e.name).join(',')}の最大MPを合計(${totalMaxMp})分吸収した!!`) } },
    // 敵単体のMPを自分のbuffs.strにするスペル
    tradeMpByStr: { name: 'MP変換(バフ)', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const tempMp = target.mp;target.mp = source.buffs.str;source.buffs.str = tempMp;logWrite(`${source.name}は${target.name}のMPとバフを入れ替えた!!`) } },
    // 敵単体の最大MPを自分のbuffs.strにするスペル
    tradeMaxMpByStr: { name: '最大MP変換(バフ)', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const tempMp = target.maxMp;target.maxMp = source.buffs.str;source.buffs.str = tempMp;logWrite(`${source.name}は${target.name}の最大MPとバフを入れ替えた!!`) } },
    // 敵全体のMPの累計を自分のbuffs.strにするスペル
    tradeMpAllByStr: { name: '全員MP変換(バフ)', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const totalMp = target.reduce((sum, enemy) => sum + enemy.mp, 0);source.buffs.str += totalMp;logWrite(`${source.name}は${target.map(e => e.name).join(',')}のMPを合計(${totalMp})分吸収した!!`) } },

    // 敵全体の数だけ自分のbuffs.strを上昇するスペル
    buffStrByEnemyCount: { name: '敵の数分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = target.length;source.buffs.str += buffAmount;logWrite(`${source.name}は${target.map(e => e.name).join(',')}の数(${buffAmount})分のバフをかけた!!`) } },
    // 敵全体の数だけ味方全員のbuffs.strを上昇するスペル
    buffStrByEnemyCount2: { name: '敵の数分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = target.length;for (let i = 0; i < heroes.length; i++) {heroes[i].buffs.str += buffAmount;}logWrite(`${source.name}は味方全員の数(${buffAmount})分のバフをかけた!!`) } },
    // 味方全体の数だけ自分のbuffs.strを上昇するスペル
    buffStrByAllCount: { name: '全員の数分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = target.length;source.buffs.str += buffAmount;logWrite(`${source.name}は味方全員の数(${buffAmount})分のバフをかけた!!`) } },
    // 味方全体の数だけ味方全員のbuffs.strを上昇するスペル
    buffStrByAllCount2: { name: '全員の数分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = target.length;for (let i = 0; i < heroes.length; i++) {heroes[i].buffs.str += buffAmount;}logWrite(`${source.name}は味方全員の数(${buffAmount})分のバフをかけた!!`) } },
    // 敵と味方の全体の合計数だけ自分のbuffs.strを上昇するスペル
    buffStrByAllCount2: { name: '全員の数分Strバフ(敵味方)', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = target.length + enemies.length;source.buffs.str += buffAmount;logWrite(`${source.name}は敵と味方全員の数(${buffAmount})分のバフをかけた!!`) } },
    // 敵と味方の全体の合計数だけ味方全員のbuffs.strを上昇するスペル
    buffStrByAllCount3: { name: '全員の数分全員Strバフ(敵味方)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = target.length + enemies.length;for (let i = 0; i < heroes.length; i++) {heroes[i].buffs.str += buffAmount;}logWrite(`${source.name}は敵と味方全員の数(${buffAmount})分のバフをかけた!!`) } },

    // 所持するアイテムの数だけ単体の味方のbuffs.strを上昇するスペル
    buffStrByItemCount: { name: 'アイテムの数分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = inventory.length;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}にアイテム(${buffAmount})分のバフをかけた!!`) } },
    // 所持するアイテムの数だけ味方全員のbuffs.strを上昇するスペル
    buffStrByItemCount2: { name: 'アイテムの数分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = inventory.length;for (let i = 0; i < heroes.length; i++) {heroes[i].buffs.str += buffAmount;}logWrite(`${source.name}は味方全員にアイテム(${buffAmount})分のバフをかけた!!`) } },

    // 戦闘回数*10だけ単体の味方のbuffs.strを上昇するスペル
    buffStrByBattleCount: { name: '戦闘回数分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = battleCount * 10;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}に戦闘回数(${buffAmount})分のバフをかけた!!`) } },
    // 戦闘回数*10だけ味方全員のbuffs.strを上昇するスペル
    buffStrByBattleCount2: { name: '戦闘回数分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = battleCount * 10;for (let i = 0; i < heroes.length; i++) {heroes[i].buffs.str += buffAmount;}logWrite(`${source.name}は味方全員に戦闘回数(${buffAmount})分のバフをかけた!!`) } },
    // 戦闘回数*100だけ単体の味方のbuffs.strを上昇するスペル
    buffStrByBattleCount3: { name: '戦闘回数分Strバフ(100倍)', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = battleCount * 100;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}に戦闘回数(${buffAmount})分のバフをかけた!!`) } },
    // 戦闘回数*100だけ味方全員のbuffs.strを上昇するスペル
    buffStrByBattleCount4: { name: '戦闘回数分全員Strバフ(100倍)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buffAmount = battleCount * 100;for (let i = 0; i < heroes.length; i++) {heroes[i].buffs.str += buffAmount;}logWrite(`${source.name}は味方全員に戦闘回数(${buffAmount})分のバフをかけた!!`) } },


    // 敵1体をランダムな別のenemyに入れ替えるスペル
    tradeEnemyRandom: { name: '敵を入れ替え(ランダム)', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const randomIndex = Math.floor(Math.random() * enemies.length);
        const temp = target[0];target[0] = enemies[randomIndex];enemies[randomIndex] = temp;logWrite(`${source.name}は${target[0].name}と${enemies[randomIndex].name}を入れ替えた!!`) } },
    // 敵全てをランダムな別のenemyに入れ替えるスペル
    tradeEnemyAllRandom: { name: '敵を入れ替え(全員ランダム)', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        for (let i = 0; i < target.length; i++) {
            const randomIndex = Math.floor(Math.random() * enemies.length);
            const temp = target[i];target[i] = enemies[randomIndex];enemies[randomIndex] = temp;
        }logWrite(`${source.name}は${target.map(e => e.name).join(',')}と${enemies.map(e => e.name).join(',')}を入れ替えた!!`) } },

    // 敵単体が持つbuffs.strを自分のbuffs.strにするスペル
    tradeEnemyBuffStr: { name: '敵のバフを吸収', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const temp = target[0].buffs.str;target[0].buffs.str = source.buffs.str;source.buffs.str = temp;logWrite(`${source.name}は${target[0].name}のバフを吸収した!!`) } },
    // 敵全体が持つbuffs.strを自分のbuffs.strにするスペル
    tradeEnemyBuffStrAll: { name: '全員のバフを吸収', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        for (let i = 0; i < target.length; i++) {
            const temp = target[i].buffs.str;target[i].buffs.str = source.buffs.str;source.buffs.str = temp;
        }logWrite(`${source.name}は${target.map(e => e.name).join(',')}のバフを吸収した!!`) } },
    // 敵全体が持つbuffs.strを味方全員のbuffs.strにするスペル
    tradeEnemyBuffStrAll2: { name: '全員のバフを吸収(全員)', cost: 0, type: 'other', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        for (let i = 0; i < target.length; i++) {
            const temp = target[i].buffs.str;target[i].buffs.str = heroes[i].buffs.str;heroes[i].buffs.str = temp;
        }logWrite(`${source.name}は${target.map(e => e.name).join(',')}のバフを吸収した!!`) } },





    // 味方全体の最大HPの平均数値を自分のbuffs.strにするスペル
    buffStrByAvgAllMaxHp: { name: '全員最大HP平均分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgMaxHp = Math.floor(heroes.reduce((sum, h) => sum + h.maxHp, 0) / heroes.length);
            source.buffs.str += avgMaxHp;
            logWrite(`${source.name}は味方全員の最大HP平均(${avgMaxHp})分のバフをかけた!!`);
        } 
    },
    // 味方全体の最大HPの平均数値を味方全体のbuffs.strにするスペル
    buffStrByAvgAllMaxHp2: { name: '全員最大HP平均分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgMaxHp = Math.floor(heroes.reduce((sum, h) => sum + h.maxHp, 0) / heroes.length);
            for (let i = 0; i < heroes.length; i++) {
                heroes[i].buffs.str += avgMaxHp;
            }
            logWrite(`${source.name}は味方全員の最大HP平均(${avgMaxHp})分のバフをかけた!!`);
        } 
    },
    // 味方全体の最大HPの平均数値を敵単体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllMaxHp: { name: '全員最大HP平均分敵HPバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgMaxHp = Math.floor(heroes.reduce((sum, h) => sum + h.maxHp, 0) / heroes.length);
            const enemyTarget = target[0];
            enemyTarget.hp = avgMaxHp;
            logWrite(`${source.name}は${enemyTarget.name}のHPを味方全員の最大HP平均(${avgMaxHp})にした!!`);
        } 
    },
    // 味方全体の最大HPの平均数値を敵全体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllMaxHp2: { name: '全員最大HP平均分敵HPバフ(全員)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgMaxHp = Math.floor(heroes.reduce((sum, h) => sum + h.maxHp, 0) / heroes.length);
            for (let i = 0; i < target.length; i++) {
                target[i].hp = avgMaxHp;
            }
            logWrite(`${source.name}は${target.map(e => e.name).join(',')}のHPを味方全員の最大HP平均(${avgMaxHp})にした!!`);
        } 
    },
    // 敵全体の最大HPの平均数値を自分のbuffs.strにするスペル
    buffStrByAvgAllEnemiesMaxHp: { name: '敵全員最大HP平均分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgMaxHp = Math.floor(enemies.reduce((sum, e) => sum + e.maxHp, 0) / enemies.length);
            source.buffs.str += avgMaxHp;
            logWrite(`${source.name}は敵全員の最大HP平均(${avgMaxHp})分のバフをかけた!!`);
        } 
    },
    // 敵全体の最大HPの平均数値を味方全体のbuffs.strにするスペル
    buffStrByAvgAllEnemiesMaxHp2: { name: '敵全員最大HP平均分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgMaxHp = Math.floor(enemies.reduce((sum, e) => sum + e.maxHp, 0) / enemies.length);
            for (let i = 0; i < heroes.length; i++) {
                heroes[i].buffs.str += avgMaxHp;
            }
            logWrite(`${source.name}は敵全員の最大HP平均(${avgMaxHp})分のバフをかけた!!`);
        } 
    },
    // 敵全体の最大HPの平均数値を敵単体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllEnemiesMaxHp: { name: '敵全員最大HP平均分敵HPバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgMaxHp = Math.floor(enemies.reduce((sum, e) => sum + e.maxHp, 0) / enemies.length);
            const enemyTarget = target[0];
            enemyTarget.hp = avgMaxHp;
            logWrite(`${source.name}は${enemyTarget.name}のHPを敵全員の最大HP平均(${avgMaxHp})にした!!`);
        } 
    },
    // 敵全体の最大HPの平均数値を敵全体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllEnemiesMaxHp2: { name: '敵全員最大HP平均分敵HPバフ(全員)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgMaxHp = Math.floor(enemies.reduce((sum, e) => sum + e.maxHp, 0) / enemies.length);
            for (let i = 0; i < target.length; i++) {
                target[i].hp = avgMaxHp;
            }
            logWrite(`${source.name}は${target.map(e => e.name).join(',')}のHPを敵全員の最大HP平均(${avgMaxHp})にした!!`);
        } 
    },
    // 味方全体のHPの平均数値を自分のbuffs.strにするスペル
    buffStrByAvgAllHp: { name: '全員HP平均分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgHp = Math.floor(heroes.reduce((sum, h) => sum + h.hp, 0) / heroes.length);
            source.buffs.str += avgHp;
            logWrite(`${source.name}は味方全員のHP平均(${avgHp})分のバフをかけた!!`);
        } 
    },
    // 味方全体のHPの平均数値を味方全体のbuffs.strにするスペル
    buffStrByAvgAllHp2: { name: '全員HP平均分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgHp = Math.floor(heroes.reduce((sum, h) => sum + h.hp, 0) / heroes.length);
            for (let i = 0; i < heroes.length; i++) {
                heroes[i].buffs.str += avgHp;
            }
            logWrite(`${source.name}は味方全員のHP平均(${avgHp})分のバフをかけた!!`);
        } 
    },
    // 味方全体のHPの平均数値を敵単体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllHp: { name: '全員HP平均分敵HPバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgHp = Math.floor(heroes.reduce((sum, h) => sum + h.hp, 0) / heroes.length);
            const enemyTarget = target[0];
            enemyTarget.hp = avgHp;
            logWrite(`${source.name}は${enemyTarget.name}のHPを味方全員のHP平均(${avgHp})にした!!`);
        } 
    },
    // 味方全体のHPの平均数値を敵全体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllHp2: { name: '全員HP平均分敵HPバフ(全員)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgHp = Math.floor(heroes.reduce((sum, h) => sum + h.hp, 0) / heroes.length);
            for (let i = 0; i < target.length; i++) {
                target[i].hp = avgHp;
            }
            logWrite(`${source.name}は${target.map(e => e.name).join(',')}のHPを味方全員のHP平均(${avgHp})にした!!`);
        } 
    },
    // 敵全体のHPの平均数値を自分のbuffs.strにするスペル
    buffStrByAvgAllEnemiesHp: { name: '敵全員HP平均分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgHp = Math.floor(enemies.reduce((sum, e) => sum + e.hp, 0) / enemies.length);
            source.buffs.str += avgHp;
            logWrite(`${source.name}は敵全員のHP平均(${avgHp})分のバフをかけた!!`);
        } 
    },
    // 敵全体のHPの平均数値を味方全体のbuffs.strにするスペル
    buffStrByAvgAllEnemiesHp2: { name: '敵全員HP平均分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgHp = Math.floor(enemies.reduce((sum, e) => sum + e.hp, 0) / enemies.length);
            for (let i = 0; i < heroes.length; i++) {
                heroes[i].buffs.str += avgHp;
            }
            logWrite(`${source.name}は敵全員のHP平均(${avgHp})分のバフをかけた!!`);
        } 
    },
    // 敵全体のHPの平均数値を敵単体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllEnemiesHp: { name: '敵全員HP平均分敵HPバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgHp = Math.floor(enemies.reduce((sum, e) => sum + e.hp, 0) / enemies.length);
            const enemyTarget = target[0];
            enemyTarget.hp = avgHp;
            logWrite(`${source.name}は${enemyTarget.name}のHPを敵全員のHP平均(${avgHp})にした!!`);
        } 
    },
    // 敵全体のHPの平均数値を敵全体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllEnemiesHp2: { name: '敵全員HP平均分敵HPバフ(全員)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, source) => {
            const avgHp = Math.floor(enemies.reduce((sum, e) => sum + e.hp, 0) / enemies.length);
            for (let i = 0; i < target.length; i++) {
                target[i].hp = avgHp;
            }
            logWrite(`${source.name}は${target.map(e => e.name).join(',')}のHPを敵全員のHP平均(${avgHp})にした!!`);
        } 
    },

    
    // 味方全体の最大MPの平均数値を自分のbuffs.strにするスペル
    buffStrByAvgAllMaxMp: { name: '全員最大MP平均分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMaxMp = Math.floor(heroes.reduce((sum, h) => sum + h.maxMp, 0) / heroes.length);
            source.buffs.str += avgMaxMp;
            logWrite(`${source.name}は味方全員の最大MP平均(${avgMaxMp})分のバフをかけた!!`);
        }
    },
    // 味方全体の最大MPの平均数値を味方全体のbuffs.strにするスペル
    buffStrByAvgAllMaxMp2: { name: '全員最大MP平均分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMaxMp = Math.floor(heroes.reduce((sum, h) => sum + h.maxMp, 0) / heroes.length);
            for (let i = 0; i < heroes.length; i++) {
                heroes[i].buffs.str += avgMaxMp;
            }
            logWrite(`${source.name}は味方全員の最大MP平均(${avgMaxMp})分のバフをかけた!!`);
        }
    },
    // 味方全体の最大MPの平均数値を敵単体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllMaxMp: { name: '全員最大MP平均分敵HPバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMaxMp = Math.floor(heroes.reduce((sum, h) => sum + h.maxMp, 0) / heroes.length);
            const enemyTarget = target[0];
            enemyTarget.hp = avgMaxMp;
            logWrite(`${source.name}は${enemyTarget.name}のHPを味方全員の最大MP平均(${avgMaxMp})にした!!`);
        }
    },
    // 味方全体の最大MPの平均数値を敵全体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllMaxMp2: { name: '全員最大MP平均分敵HPバフ(全員)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMaxMp = Math.floor(heroes.reduce((sum, h) => sum + h.maxMp, 0) / heroes.length);
            for (let i = 0; i < target.length; i++) {
                target[i].hp = avgMaxMp;
            }
            logWrite(`${source.name}は${target.map(e => e.name).join(',')}のHPを味方全員の最大MP平均(${avgMaxMp})にした!!`);
        }
    },
    // 敵全体の最大MPの平均数値を自分のbuffs.strにするスペル
    buffStrByAvgAllEnemiesMaxMp: { name: '敵全員最大MP平均分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMaxMp = Math.floor(enemies.reduce((sum, e) => sum + e.maxMp, 0) / enemies.length);
            source.buffs.str += avgMaxMp;
            logWrite(`${source.name}は敵全員の最大MP平均(${avgMaxMp})分のバフをかけた!!`);
        }
    },
    // 敵全体の最大MPの平均数値を味方全体のbuffs.strにするスペル
    buffStrByAvgAllEnemiesMaxMp2: { name: '敵全員最大MP平均分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMaxMp = Math.floor(enemies.reduce((sum, e) => sum + e.maxMp, 0) / enemies.length);
            for (let i = 0; i < heroes.length; i++) {
                heroes[i].buffs.str += avgMaxMp;
            }
            logWrite(`${source.name}は敵全員の最大MP平均(${avgMaxMp})分のバフをかけた!!`);
        }
    },
    // 敵全体の最大MPの平均数値を敵単体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllEnemiesMaxMp: { name: '敵全員最大MP平均分敵HPバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMaxMp = Math.floor(enemies.reduce((sum, e) => sum + e.maxMp, 0) / enemies.length);
            const enemyTarget = target[0];
            enemyTarget.hp = avgMaxMp;
            logWrite(`${source.name}は${enemyTarget.name}のHPを敵全員の最大MP平均(${avgMaxMp})にした!!`);
        }
    },
    // 敵全体の最大MPの平均数値を敵全体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllEnemiesMaxMp2: { name: '敵全員最大MP平均分敵HPバフ(全員)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMaxMp = Math.floor(enemies.reduce((sum, e) => sum + e.maxMp, 0) / enemies.length);
            for (let i = 0; i < target.length; i++) {
                target[i].hp = avgMaxMp;
            }
            logWrite(`${source.name}は${target.map(e => e.name).join(',')}のHPを敵全員の最大MP平均(${avgMaxMp})にした!!`);
        }
    },
    // 味方全体のMPの平均数値を自分のbuffs.strにするスペル
    buffStrByAvgAllMp: { name: '全員MP平均分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMp = Math.floor(heroes.reduce((sum, h) => sum + h.mp, 0) / heroes.length);
            source.buffs.str += avgMp;
            logWrite(`${source.name}は味方全員のMP平均(${avgMp})分のバフをかけた!!`);
        }
    },
    // 味方全体のMPの平均数値を味方全体のbuffs.strにするスペル
    buffStrByAvgAllMp2: { name: '全員MP平均分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMp = Math.floor(heroes.reduce((sum, h) => sum + h.mp, 0) / heroes.length);
            for (let i = 0; i < heroes.length; i++) {
                heroes[i].buffs.str += avgMp;
            }
            logWrite(`${source.name}は味方全員のMP平均(${avgMp})分のバフをかけた!!`);
        }
    },
    // 味方全体のMPの平均数値を敵単体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllMp: { name: '全員MP平均分敵HPバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMp = Math.floor(heroes.reduce((sum, h) => sum + h.mp, 0) / heroes.length);
            const enemyTarget = target[0];
            enemyTarget.hp = avgMp;
            logWrite(`${source.name}は${enemyTarget.name}のHPを味方全員のMP平均(${avgMp})にした!!`);
        }
    },
    // 味方全体のMPの平均数値を敵全体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllMp2: { name: '全員MP平均分敵HPバフ(全員)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMp = Math.floor(heroes.reduce((sum, h) => sum + h.mp, 0) / heroes.length);
            for (let i = 0; i < target.length; i++) {
                target[i].hp = avgMp;
            }
            logWrite(`${source.name}は${target.map(e => e.name).join(',')}のHPを味方全員のMP平均(${avgMp})にした!!`);
        }
    },
    // 敵全体のMPの平均数値を自分のbuffs.strにするスペル
    buffStrByAvgAllEnemiesMp: { name: '敵全員MP平均分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMp = Math.floor(enemies.reduce((sum, e) => sum + e.mp, 0) / enemies.length);
            source.buffs.str += avgMp;
            logWrite(`${source.name}は敵全員のMP平均(${avgMp})分のバフをかけた!!`);
        }
    },
    // 敵全体のMPの平均数値を味方全体のbuffs.strにするスペル
    buffStrByAvgAllEnemiesMp2: { name: '敵全員MP平均分全員Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMp = Math.floor(enemies.reduce((sum, e) => sum + e.mp, 0) / enemies.length);
            for (let i = 0; i < heroes.length; i++) {
                heroes[i].buffs.str += avgMp;
            }
            logWrite(`${source.name}は敵全員のMP平均(${avgMp})分のバフをかけた!!`);
        }
    },
    // 敵全体のMPの平均数値を敵単体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllEnemiesMp: { name: '敵全員MP平均分敵HPバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMp = Math.floor(enemies.reduce((sum, e) => sum + e.mp, 0) / enemies.length);
            const enemyTarget = target[0];
            enemyTarget.hp = avgMp;
            logWrite(`${source.name}は${enemyTarget.name}のHPを敵全員のMP平均(${avgMp})にした!!`);
        }
    },
    // 敵全体のMPの平均数値を敵全体のHPの平均数値にするスペル
    buffEnemyHpByAvgAllEnemiesMp2: { name: '敵全員MP平均分敵HPバフ(全員)', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {
            const avgMp = Math.floor(enemies.reduce((sum, e) => sum + e.mp, 0) / enemies.length);
            for (let i = 0; i < target.length; i++) {
                target[i].hp = avgMp;
            }
            logWrite(`${source.name}は${target.map(e => e.name).join(',')}のHPを敵全員のMP平均(${avgMp})にした!!`);
        }
    },



    // 単体の敵と自らを入れ替えるスペル(未テスト 他のコードも変更する必要あり)
    tradeEnemy: { name: '敵と入れ替え', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const temp = target[0];target[0] = source;source = temp;logWrite(`${source.name}は${target[0].name}と入れ替えた!!`) } },

    // 単体の敵のスペルを自らにコピーするスペル(未テスト 他のコードも変更する必要あり)
    copyEnemySpell: { name: '敵のスペルをコピー', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const temp = target[0];target[0] = source;source = temp;logWrite(`${source.name}は${target[0].name}のスペルをコピーした!!`) } },




    // 単体の味方にLvの数だけbuffs.strに上昇するスペル
    buffStrByLevel: { name: 'レベル分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = source.level;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}にレベル(${buffAmount})分のバフをかけた!!`) } },
    // 単体の味方に最大HPの数だけbuffs.strに上昇するスペル
    buffStrByMaxHp: { name: '最大HP分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = buff_target.maxHp;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}に最大HP(${buffAmount})分のバフをかけた!!`) } },
    // 単体の味方に最大MPの数だけbuffs.strに上昇するスペル
    buffStrByMaxMp: { name: '最大MP分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = buff_target.maxMp;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}に最大MP(${buffAmount})分のバフをかけた!!`) } },
    // 単体の味方にHPの数だけbuffs.strに上昇するスペル
    buffStrByHp: { name: 'HP分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = buff_target.hp;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}にHP(${buffAmount})分のバフをかけた!!`) } },
    // 単体の味方にMPの数だけbuffs.strに上昇するスペル
    buffStrByMp: { name: 'MP分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = buff_target.mp;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}にMP(${buffAmount})分のバフをかけた!!`) } },
    // 味方全体に最大HPの数だけbuffs.strに上昇するスペル
    buffStrByAllMaxHp: { name: '全員最大HP分Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        for (let i = 0; i < target.length; i++) {const buff_target = target[i];const buffAmount = buff_target.maxHp;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}に最大HP(${buffAmount})分のバフをかけた!!`) } } },
    // 味方全体に最大MPの数だけbuffs.strに上昇するスペル
    buffStrByAllMaxMp: { name: '全員最大MP分Strバフ', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        for (let i = 0; i < target.length; i++) {const buff_target = target[i];const buffAmount = buff_target.maxMp;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}に最大MP(${buffAmount})分のバフをかけた!!`) } } },
    // 単体の味方のbuffs.strを2倍にするスペル(現在の数値が0の場合は2倍にならない)
    buffStrDouble: { name: 'Strバフ2倍', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        if (buff_target.buffs.str > 0) {buff_target.buffs.str *= 2;logWrite(`${source.name}は${buff_target.name}のStrバフを2倍にした!!`) } } },
    // 味方全体のbuffs.strを2倍にするスペル(現在の数値が0の場合は2倍にならない)
    buffStrDoubleAll: { name: '全員Strバフ2倍', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        for (let i = 0; i < target.length; i++) {const buff_target = target[i];if (buff_target.buffs.str > 0) {buff_target.buffs.str *= 2;logWrite(`${source.name}は${buff_target.name}のStrバフを2倍にした!!`) } } } },
    // 単体の味方のbuffs.strを10倍にするスペル(現在の数値が0の場合は10倍にならない)
    buffStrTenTimes: { name: 'Strバフ10倍', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        if (buff_target.buffs.str > 0) {buff_target.buffs.str *= 10;logWrite(`${source.name}は${buff_target.name}のStrバフを10倍にした!!`) } } },
    // 味方全体のbuffs.strを10倍にするスペル(現在の数値が0の場合は10倍にならない)
    buffStrTenTimesAll: { name: '全員Strバフ10倍', cost: 0, type: 'buff', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        for (let i = 0; i < target.length; i++) {const buff_target = target[i];if (buff_target.buffs.str > 0) {buff_target.buffs.str *= 10;logWrite(`${source.name}は${buff_target.name}のStrバフを10倍にした!!`) } } } },
    // 所持するexpの数だけbuffs.strに上昇するスペル
    buffStrByExp: { name: '所持exp分Strバフ', cost: 0, type: 'buff', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const buff_target = target[0];
        const buffAmount = source.exp;buff_target.buffs.str += buffAmount;logWrite(`${source.name}は${buff_target.name}に所持exp(${buffAmount})分のバフをかけた!!`) } },
    // 所持するexpの数だけ単体の敵にダメージを与えるスペル
    dmgByExp: { name: '所持exp分ダメージ', cost: 0, type: 'dmg', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const dmgAmount = source.exp;target.hp -= dmgAmount;logWrite(`${source.name}は${target.name}に所持exp(${dmgAmount})分のダメージを与えた!!`) } },
    // caster単体の所持するexpの数だけ敵全体にダメージを与えるスペル
    dmgByAllExp: { name: '所持exp分全体ダメージ', cost: 0, type: 'dmg', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const dmgAmount = source.exp;for (let i = 0; i < target.length; i++) {const enemy = target[i];enemy.hp -= dmgAmount;logWrite(`${source.name}は${enemy.name}に所持exp(${dmgAmount})分のダメージを与えた!!`) } } },
    // 味方全体の所持するexpの合計数だけ敵単体にダメージを与えるスペル
    dmgByAllExpSingle: { name: '所持exp分全体ダメージ(単体)', cost: 0, type: 'dmg', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const dmgAmount = heroes.reduce((sum, hero) => sum + hero.exp, 0);target.hp -= dmgAmount;logWrite(`${source.name}は${target.name}に所持exp(${dmgAmount})分のダメージを与えた!!`) } },
    // 味方全体の所持するexpの合計数だけ敵全体にダメージを与えるスペル
    dmgByAllExpAll: { name: '所持exp分全体ダメージ(全体)', cost: 0, type: 'dmg', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const dmgAmount = heroes.reduce((sum, hero) => sum + hero.exp, 0);for (let i = 0; i < target.length; i++) {const enemy = target[i];enemy.hp -= dmgAmount;logWrite(`${source.name}は${enemy.name}に所持exp(${dmgAmount})分のダメージを与えた!!`) } } },
    // buffs.str*最大MPの数を敵単体にダメージを与えるスペル
    dmgByBuffStrMaxMp: { name: 'バフStr*最大MP分ダメージ', cost: 0, type: 'dmg', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const dmgAmount = source.buffs.str * source.maxMp;target.hp -= dmgAmount;logWrite(`${source.name}は${target.name}にバフStr(${source.buffs.str})*最大MP(${source.maxMp})分のダメージを与えた!!`) } },
    // buffs.str*最大MPの数を敵全体にダメージを与えるスペル
    dmgByBuffStrMaxMpAll: { name: 'バフStr*最大MP分全体ダメージ', cost: 0, type: 'dmg', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const dmgAmount = source.buffs.str * source.maxMp;for (let i = 0; i < target.length; i++) {const enemy = target[i];enemy.hp -= dmgAmount;logWrite(`${source.name}は${enemy.name}にバフStr(${source.buffs.str})*最大MP(${source.maxMp})分のダメージを与えた!!`) } } },
    // buffs.str*最大HPの数を敵単体にダメージを与えるスペル
    dmgByBuffStrMaxHp: { name: 'バフStr*最大HP分ダメージ', cost: 0, type: 'dmg', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const dmgAmount = source.buffs.str * source.maxHp;target.hp -= dmgAmount;logWrite(`${source.name}は${target.name}にバフStr(${source.buffs.str})*最大HP(${source.maxHp})分のダメージを与えた!!`) } },
    // buffs.str*最大HPの数を敵全体にダメージを与えるスペル
    dmgByBuffStrMaxHpAll: { name: 'バフStr*最大HP分全体ダメージ', cost: 0, type: 'dmg', range: 'all', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {
        const dmgAmount = source.buffs.str * source.maxHp;for (let i = 0; i < target.length; i++) {const enemy = target[i];enemy.hp -= dmgAmount;logWrite(`${source.name}は${enemy.name}にバフStr(${source.buffs.str})*最大HP(${source.maxHp})分のダメージを与えた!!`) } } },




    

    


    // 単体の敵の最大HPの量だけMPを回復する(最大MPまで充填できる)スペル
    recoverMpByEnemyMaxHp: {name: '敵最大HP分MP回復',cost: 0,type: 'other',range: 'single',val: [0, 0],requiredJobs: { 戦士: 2, 僧侶: 2 },effect: (target, source) => {console.log("xxxXXX");const recoverAmount = target.maxHp;source.mp = recoverAmount > source.maxMp ? source.maxMp : recoverAmount;logWrite(`${source.name}は${target.name}の最大HP(${recoverAmount})分MPを回復した!!`)}},
    // 単体の敵の最大HPの量だけMPを回復する(最大MPを超えて充填できる)スペル
    recoverMpByEnemyMaxHpOver: {name: '敵最大HP分MP回復(リミットブレイク)',cost: 0,type: 'other',range: 'single',val: [0, 0],requiredJobs: { 戦士: 2, 僧侶: 2 },effect: (target, source) => {const recoverAmount = target.maxHp;source.mp += recoverAmount;logWrite(`${source.name}は${target.name}の最大HP(${recoverAmount})分MPを回復した!!`)}},
    // 敵全員の最大HPの合計だけMPを回復する(最大MPまで充填できる)スペル
    recoverMpByAllEnemiesMaxHp: {name: '敵全員最大HP分MP回復',cost: 0,type: 'other',range: 'single',val: [0, 0],requiredJobs: { 戦士: 2, 僧侶: 2 },effect: (target, source) => {const recoverAmount = enemies.reduce((sum, enemy) => sum + enemy.maxHp, 0);source.mp = recoverAmount > source.maxMp ? source.maxMp : recoverAmount;logWrite(`${source.name}は敵全員の最大HP(${recoverAmount})分MPを回復した!!`)}},
    // 敵全員の最大HPの合計だけMPを回復する(最大MPを超えて充填できる)スペル
    recoverMpByAllEnemiesMaxHpOver: {name: '敵全員最大HP分MP回復(リミットブレイク)',cost: 0,type: 'other',range: 'single',val: [0, 0],requiredJobs: { 戦士: 2, 僧侶: 2 },effect: (target, source) => {const recoverAmount = enemies.reduce((sum, enemy) => sum + enemy.maxHp, 0);source.mp += recoverAmount;logWrite(`${source.name}は敵全員の最大HP(${recoverAmount})分MPを回復した!!`)}},
    // 単体の敵の最大MPの量だけMPを回復する(最大MPまで充填できる)スペル
    recoverMpByEnemyMaxMp: {name: '敵最大MP分MP回復',cost: 0,type: 'other',range: 'single',val: [0, 0],requiredJobs: { 戦士: 2, 僧侶: 2 },effect: (target, source) => {const recoverAmount = target.maxMp;source.mp = recoverAmount > source.maxMp ? source.maxMp : recoverAmount;logWrite(`${source.name}は${target.name}の最大MP(${recoverAmount})分MPを回復した!!`)}},
    // 単体の敵の最大MPの量だけMPを回復する(最大MPを超えて充填できる)スペル
    recoverMpByEnemyMaxMpOver: {name: '敵最大MP分MP回復(リミットブレイク)',cost: 0,type: 'other',range: 'single',val: [0, 0],requiredJobs: { 戦士: 2, 僧侶: 2 },effect: (target, source) => {const recoverAmount = target.maxMp;source.mp += recoverAmount;logWrite(`${source.name}は${target.name}の最大MP(${recoverAmount})分MPを回復した!!`)}},
    // 敵全員の最大MPの合計だけMPを回復する(最大MPまで充填できる)スペル
    recoverMpByAllEnemiesMaxMp: {name: '敵全員最大MP分MP回復',cost: 0,type: 'other',range: 'single',val: [0, 0],requiredJobs: { 戦士: 2, 僧侶: 2 },effect: (target, source) => {const recoverAmount = enemies.reduce((sum, enemy) => sum + enemy.maxMp, 0);source.mp = recoverAmount > source.maxMp ? source.maxMp : recoverAmount;logWrite(`${source.name}は敵全員の最大MP(${recoverAmount})分MPを回復した!!`)}},
    // 敵全員の最大MPの合計だけMPを回復する(最大MPを超えて充填できる)スペル
    recoverMpByAllEnemiesMaxMpOver: {name: '敵全員最大MP分MP回復(リミットブレイク)',cost: 0,type: 'other',range: 'single',val: [0, 0],requiredJobs: { 戦士: 2, 僧侶: 2 },effect: (target, source) => {const recoverAmount = enemies.reduce((sum, enemy) => sum + enemy.maxMp, 0);source.mp += recoverAmount;logWrite(`${source.name}は敵全員の最大MP(${recoverAmount})分MPを回復した!!`)}},



    // 敵の最大MPと同じ量のダメージのスペル
    dealMaxMpDmg: { name: '最大MPダメージ', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const dealAmount = target.maxMp;target.hp -= dealAmount;logWrite(`${source.name}が${target.name}の最大MPをダメージとして食らわせた!!`) } },
    // 敵の最大MPの倍の量のダメージのスペル
    dealMaxDoubleMpDmg: { name: '最大MP2倍ダメージ', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const dealAmount = target.maxMp*2;target.hp -= dealAmount;logWrite(`${source.name}が${target.name}の最大MPをダメージとして食らわせた!!`) } },
    // 敵のMPの量のダメージのスペル
    dealMpDmg: { name: 'MPダメージ', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const dealAmount = target.mp;target.hp -= dealAmount;logWrite(`${source.name}が${target.name}のMPをダメージとして食らわせた!!`) } },
    // 敵のMPの倍の量のダメージのスペル
    dealDoubleMpDmg: { name: 'MP2倍ダメージ', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const dealAmount = target.mp*2;target.hp -= dealAmount;logWrite(`${source.name}が${target.name}のMPをダメージとして食らわせた!!`) } },

    // 敵の最大MPと同じ量のダメージを敵全員に与えるスペル
    dealMaxMpDmgAll: { name: '最大MPダメージ全員', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {const dealAmount = target.maxMp;
        for (let i = 0; i < enemies.length; i++) {const enemy = enemies[i];enemy.hp -= dealAmount;logWrite(`${source.name}が${enemy.name}の最大MPをダメージとして食らわせた!!`);}
    } },
    
    // 敵の最大HPと1/4の量のダメージのスペル
    dealQuarterMaxHpDmg: { name: '最大HP1/4ダメージ', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const dealAmount = Math.floor(target.maxHp * 0.25);target.hp -= dealAmount;logWrite(`${source.name}が${target.name}の最大HPをダメージとして食らわせた!!`) } },
    // 敵の最大HPの半分の量のダメージのスペル
    dealHalfMaxHpDmg: { name: '最大HP1/2ダメージ', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const dealAmount = Math.floor(target.maxHp * 0.5);target.hp -= dealAmount;logWrite(`${source.name}が${target.name}の最大HPをダメージとして食らわせた!!`) } },
    // 敵の最大HPの量のダメージのスペル
    dealMaxHpDmg: { name: '最大HPダメージ', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, effect: (target, source) => {const dealAmount = target.maxHp;target.hp -= dealAmount;logWrite(`${source.name}が${target.name}の最大HPをダメージとして食らわせた!!`) } },
    // 敵の最大HPと1/4の量のダメージを敵全員に与えるスペル
    dealQuarterMaxHpDmgAll: { name: '最大HP1/4ダメージ全員', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {const dealAmount = Math.floor(target.maxHp * 0.25);
        for (let i = 0; i < enemies.length; i++) {const enemy = enemies[i];enemy.hp -= dealAmount;logWrite(`${source.name}が${enemy.name}の最大HPをダメージとして食らわせた!!`);}
    } },
    // 敵の最大HPと半分の量のダメージを敵全員に与えるスペル
    dealHalfMaxHpDmgAll: { name: '最大HP1/2ダメージ全員', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {const dealAmount = Math.floor(target.maxHp * 0.5);
        for (let i = 0; i < enemies.length; i++) {const enemy = enemies[i];enemy.hp -= dealAmount;logWrite(`${source.name}が${enemy.name}の最大HPをダメージとして食らわせた!!`);}
    } },

    // enemiesの数だけ単体の敵にダメージを与えるスペル
    dealSingleDmgAll: { name: '敵数ダメージ単体', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {const dealAmount = enemies.length;
        target.hp -= dealAmount;logWrite(`${source.name}が${target.name}にダメージを与えた!!`);}
    },

    // enemiesの数だけ全体の敵にダメージを与えるスペル
    dealAllDmgAll: { name: '敵数ダメージ全体', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {const dealAmount = enemies.length;
        for (let i = 0; i < enemies.length; i++) {const enemy = enemies[i];enemy.hp -= dealAmount;logWrite(`${source.name}が${enemy.name}にダメージを与えた!!`);}
    } },
    // heroesの数だけ単体の敵にダメージを与えるスペル
    dealSingleDmgHeroes: { name: '味方数ダメージ単体', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {const dealAmount = heroes.length;
        target.hp -= dealAmount;logWrite(`${source.name}が${target.name}にダメージを与えた!!`);}
    },
    // heroesの数だけ全体の敵にダメージを与えるスペル
    dealAllDmgHeroes: { name: '味方数ダメージ全体', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
        effect: (target, source) => {const dealAmount = heroes.length;
        for (let i = 0; i < enemies.length; i++) {const enemy = enemies[i];enemy.hp -= dealAmount;logWrite(`${source.name}が${enemy.name}にダメージを与えた!!`);}
    } },




    // 実行したキャラクタに対象からMPを吸収する
    drainMp: { name: 'MP吸収', cost: 0, type: 'other', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 },
    effect: (target, source) => {const drainAmount = Math.floor(target.mp * 0.5);target.mp -= drainAmount;source.mp += drainAmount;logWrite(`${source.name}が${target.name}からMPを吸収した!!`) } },

    tsuyoiItami: { name: '強い痛み', cost: 20, type: 'dmg', range: 'single', val: [50, 70], requiredJobs: { 魔法使い: 3 } },

    // 選択した敵と同じモンスター1体を味方に召喚するスペル
    summonSameMonster: { name: '同じモンスター召喚', cost: 0, type: 'summon', range: 'single', val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, caster) => {
            const monster = ENEMY_LIST.find(e => e.name === target.name);
            if (monster) {
                const summonedHero = createHero(monster.name, '戦士');
                summonedHero.hp = summonedHero.maxHp;
                summonedHero.mp = summonedHero.maxMp;
                summonedHero.learnedSpells = [];
                heroes.push(summonedHero);
                logWrite(`召喚を唱えた！${summonedHero.name}が味方になった!!`);
            } else {
                logWrite(`召喚に失敗した！`);
            }
        } 
    },
    // 味方にランダムでモンスターを召喚するスペル
    summonRandomMonster: { name: '適当召喚', cost: 0, type: 'summon', range: null, val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (caster) => {
            const monster = ENEMY_LIST[rand(0, ENEMY_LIST.length - 1)];
            // ヒーローとして追加（職業は"戦士"など適宜）
            const summonedHero = createHero(monster.name, '戦士');
            summonedHero.hp = summonedHero.maxHp;
            summonedHero.mp = summonedHero.maxMp;
            summonedHero.learnedSpells = [];
            heroes.push(summonedHero);
            logWrite(`召喚を唱えた！${summonedHero.name}が味方になった!!`);
        } 
    },
    // 味方の平均レベルに近いモンスターを召喚するスペル
    summonNormalMonster: { name: '普通召喚', cost: 0, type: 'summon', range: null, val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, caster) => {
            const averageLevel = Math.round(heroes.reduce((sum, hero) => sum + hero.level, 0) / heroes.length);
            let similarLevelEnemies = ENEMY_LIST.filter(e => Math.abs(e.level - averageLevel) <= 1);
            if (similarLevelEnemies.length === 0) similarLevelEnemies = ENEMY_LIST;
            const monster = similarLevelEnemies[rand(0, similarLevelEnemies.length - 1)];
            const summonedHero = createHero(monster.name, '戦士');
            summonedHero.hp = summonedHero.maxHp;
            summonedHero.mp = summonedHero.maxMp;
            summonedHero.learnedSpells = [];
            heroes.push(summonedHero);
            logWrite(`召喚を唱えた！${summonedHero.name}が味方になった!!`);
        } 
    },
    // 味方の平均レベルに近いモンスターを味方の最大数まで召喚するスペル
    summonAllies: { name: '最大召喚', cost: 0, type: 'summon', range: null, val: [0, 0], requiredJobs: { 戦士: 2, 僧侶: 2 }, 
        effect: (target, caster) => {
            const averageLevel = Math.round(heroes.reduce((sum, hero) => sum + hero.level, 0) / heroes.length);
            let similarLevelEnemies = ENEMY_LIST.filter(e => Math.abs(e.level - averageLevel) <= 1);
            if (similarLevelEnemies.length === 0) similarLevelEnemies = ENEMY_LIST;
            for (let i = 0; i < MAX_HEROES - heroes.length; i++) {
                const monster = similarLevelEnemies[rand(0, similarLevelEnemies.length - 1)];
                const summonedHero = createHero(monster.name, '戦士');
                summonedHero.hp = summonedHero.maxHp;
                summonedHero.mp = summonedHero.maxMp;
                summonedHero.learnedSpells = [];
                heroes.push(summonedHero);
                logWrite(`召喚を唱えた！${summonedHero.name}が味方になった!!`);
            }
            // MAX_HEROESに満たない場合は、残りをsimilarLevelEnemiesからランダムに召喚
            const remainingCount = MAX_HEROES - heroes.length;
            for (let i = 0; i < remainingCount; i++) {
                const monster = similarLevelEnemies[rand(0, similarLevelEnemies.length - 1)];
                const summonedHero = createHero(monster.name, '戦士');
                summonedHero.hp = summonedHero.maxHp;
                summonedHero.mp = summonedHero.maxMp;
                summonedHero.learnedSpells = [];
                heroes.push(summonedHero);
                logWrite(`召喚を唱えた！${summonedHero.name}が味方になった!!`);
            }

        } 
    },




};

const ULT_SPELLS = {
    kuro: { name: '黒', cost: 6, type: 'dmg', range: 'all', val: [10, 15], requiredJobs: { 黒魔道士: 1 } },
    // shiro: { name: '白', cost: 6, type: 'heal', range: 'all', val: [10, 15], requiredJobs: { 白魔道士: 1 } },
    // saisei: { name: '再生', cost: 20, type: 'heal', range: 'single', val: [50, 70], requiredJobs: { 僧侶: 3 } },
    // tsuyoiItami: { name: '強い痛み', cost: 20, type: 'dmg', range: 'single', val: [50, 70], requiredJobs: { 魔法使い: 3 } },
    fukaiKuro: { name: '深い黒', cost: 25, type: 'dmg', range: 'all', val: [30, 50], requiredJobs: { 黒魔道士: 6 } },
    // mabayuiShiro: { name: '眩い白', cost: 25, type: 'heal', range: 'all', val: [30, 50], requiredJobs: { 白魔道士: 6 } },
    sakebi: { name: '叫び', cost: 0, type: 'dmg', range: 'all', val: [5, 10], requiredJobs: { 戦士: 4 } },
    houkou: { name: '咆哮', cost: 0, type: 'dmg', range: 'all', val: [10, 15], requiredJobs: { 戦士: 6 } },
    // tetsuheiYu: { name: '鉄壁癒', cost: 5, type: 'heal', range: 'single', val: [30, 50], requiredJobs: { 戦士: 2, 僧侶: 2 } },
    // senshinOn: { name: '戦神恩', cost: 10, type: 'heal', range: 'all', val: [40, 60], requiredJobs: { 戦士: 4, 僧侶: 4 } },
    makenJin: { name: '魔斬刃', cost: 5, type: 'dmg', range: 'single', val: [30, 50], requiredJobs: { 戦士: 2, 魔法使い: 2 } },
    kenmaJin: { name: '剣魔陣', cost: 10, type: 'dmg', range: 'all', val: [40, 60], requiredJobs: { 戦士: 4, 魔法使い: 4 } },
    kokuenGe: { name: '黒炎撃', cost: 5, type: 'dmg', range: 'single', val: [30, 50], requiredJobs: { 戦士: 2, 黒魔道士: 2 } },
    anzanJin: { name: '暗斬陣', cost: 10, type: 'dmg', range: 'all', val: [40, 60], requiredJobs: { 戦士: 4, 黒魔道士: 4 } },
    // seigoJin: { name: '聖護陣', cost: 5, type: 'heal', range: 'single', val: [30, 50], requiredJobs: { 戦士: 2, 白魔道士: 2 } },
    // kosenKo: { name: '光戦鼓', cost: 10, type: 'heal', range: 'all', val: [40, 60], requiredJobs: { 戦士: 4, 白魔道士: 4 } },
    // iyaseiKo: { name: '癒精光', cost: 10, type: 'heal', range: 'single', val: [30, 50], requiredJobs: { 僧侶: 2, 魔法使い: 2 } },
    // kamiiyuWa: { name: '神癒輪', cost: 20, type: 'heal', range: 'all', val: [40, 60], requiredJobs: { 僧侶: 4, 魔法使い: 4 } },
    yamiyuHo: { name: '闇癒法', cost: 10, type: 'dmg', range: 'single', val: [30, 50], requiredJobs: { 僧侶: 2, 黒魔道士: 2 } },
    kuroFukuin: { name: '黒福音', cost: 20, type: 'dmg', range: 'all', val: [40, 60], requiredJobs: { 僧侶: 4, 黒魔道士: 4 } },
    // seiyuJutsu: { name: '清癒術', cost: 10, type: 'heal', range: 'single', val: [30, 50], requiredJobs: { 僧侶: 2, 白魔道士: 2 } },
    // kodoRin: { name: '光導輪', cost: 20, type: 'heal', range: 'all', val: [40, 60], requiredJobs: { 僧侶: 4, 白魔道士: 4 } },
    mashoJin: { name: '魔焼陣', cost: 10, type: 'dmg', range: 'single', val: [30, 50], requiredJobs: { 魔法使い: 2, 黒魔道士: 2 } },
    meishoHa: { name: '冥衝波', cost: 20, type: 'dmg', range: 'all', val: [40, 60], requiredJobs: { 魔法使い: 4, 黒魔道士: 4 } },
    // seikoJutsu: { name: '精光術', cost: 10, type: 'heal', range: 'single', val: [30, 50], requiredJobs: { 魔法使い: 2, 白魔道士: 2 } },
    // kamiiyuMon: { name: '神癒紋', cost: 20, type: 'heal', range: 'all', val: [40, 60], requiredJobs: { 魔法使い: 4, 白魔道士: 4 } },
    // konmeiYu: { name: '昏明癒', cost: 10, type: 'heal', range: 'single', val: [30, 50], requiredJobs: { 黒魔道士: 2, 白魔道士: 2 } },
    // seiAnRin: { name: '聖闇輪', cost: 20, type: 'heal', range: 'all', val: [40, 60], requiredJobs: { 黒魔道士: 4, 白魔道士: 4 } },


};

// アクセサリのデータ構造
const ACCESSORY_LIST = [
    { name: '力の指輪', buff: 'str', value: 10, apply_type: 'add' },
    { name: '守りのペンダント', buff: 'hp', value: 20, apply_type: 'add' },
    { name: '魔力のイヤリング', buff: 'mp', value: 15, apply_type: 'add' },
    { name: '攻撃の腕輪', buff: 'str', value: 0.2, apply_type: 'multiply' },
    { name: '生命の指輪', buff: 'hp', value: 0.1, apply_type: 'multiply' },
];

// 戦闘終了時にアクセサリをドロップ
function dropAccessories(enemyCount) {
    const totalDropChance = enemyCount * (ACCESSORY_DROP_RATE / 100); // 敵の数に応じた期待値
    const dropCount = Math.floor(totalDropChance); // 確定ドロップ数
    const additionalDrop = Math.random() < (totalDropChance - dropCount) ? 1 : 0; // 端数分の確率で追加ドロップ
    const totalDrops = dropCount + additionalDrop;
    const droppedAccessories = [];
    for (let i = 0; i < totalDrops; i++) {
        const randomAccessory = ACCESSORY_LIST[rand(0, ACCESSORY_LIST.length - 1)];
        droppedAccessories.push(randomAccessory);
    }
    return droppedAccessories;
}

// アクセサリを装備する関数
function equipAccessory(hero, accessory) {
    if (!hero.accessories) {hero.accessories = []} // アクセサリの配列を初期化
    if (hero.accessories.length >= MAX_ACCESSORIES_PER_HERO) {
        logWrite(`${hero.name}はこれ以上アクセサリを装備できません。`);
        return;
    }
    hero.accessories.push(accessory);
    logWrite(`${hero.name}は「${accessory.name}」を装備しました！`);
}

// 戦闘終了時にアクセサリを選択して装備
function showAccessorySelection(droppedAccessories) {
    actions.innerHTML = `<strong>ドロップしたアクセサリを装備してください:</strong>`;
    droppedAccessories.forEach((accessory, index) => {
        heroes.forEach((hero, heroIndex) => {
            const accessoryButton = document.createElement('button');
            accessoryButton.textContent = `${hero.name}に「${accessory.name}」を装備`;
            accessoryButton.onclick = () => {
                equipAccessory(hero, accessory);
                droppedAccessories.splice(index, 1); // ドロップリストから削除
                if (droppedAccessories.length === 0) {
                    logWrite('全てのアクセサリを装備しました。');
                    showInnOrTemple(); // 次の選択肢へ
                } else {
                    showAccessorySelection(droppedAccessories); // 再描画
                }
            };
            actions.appendChild(accessoryButton);
        });
    });

    const skipButton = document.createElement('button');
    skipButton.textContent = '装備せず破棄';
    skipButton.onclick = () => {
        logWrite('装備しなかったアクセサリは破棄されました。');
        showInnOrTemple(); // 次の選択肢へ
    };
    actions.appendChild(skipButton);
}

// 戦闘開始時に全キャラクターのアクセサリ効果を適用
function startBattle(enemyCount = 2) {
    const clearLog = () => log.innerHTML = ''; // ログをクリアする関数
    clearLog();
    spawnEnemies(enemyCount);
    logWrite(`敵が${enemies.length}体あらわれた！（戦闘回数: ${battleCount}）`);
    updateEnemies();
    // 戦闘開始時にアクセサリの効果を適用
    function applyAccessoryEffects(hero) {
        if (hero.accessories) {
            hero.accessories.forEach(accessory => {
                applyBattleBuff(hero, accessory.buff, accessory.apply_type, accessory.value);
            });
        }
    }
    heroes.forEach(hero => applyAccessoryEffects(hero)); // アクセサリ効果を適用
    isEnemyTurn = false; // プレイヤーのターンから開始
    nextTurn();
}

function createHero(name, job) {
    const b = JOBS[job];
    return {
        name,
        job,
        level: 1,
        exp: 0,
        maxHp: b.hp,
        hp: b.hp,
        maxMp: b.mp,
        mp: b.mp,
        alive: true,
        jobHistory: { [job]: 1 },
        buffs: { hp: 0, mp: 0, str: 0 }, // 戦闘中の補正値
        get str() {
            return Math.floor(this.maxHp * STR_PERCENTAGE) + this.buffs.str;
        },
    };
}

function logWrite(msg) {
    log.innerHTML = `<div>${msg}</div>` + log.innerHTML; // 最新のメッセージを先頭に追加
    log.scrollTop = 0; // スクロールを一番上に設定
}

function allHeroesAttack() {
    heroes.filter(h => h.alive).forEach(hero => {
        const target = enemies.find(e => e.alive); // 最初の生存している敵をターゲット
        if (target) {
            actionsQueue.push({ hero, action: 'attack', target });
        }
    });
    executeHeroActions(); // 全員の攻撃を即時実行
}

// function showHeroActionSelection() {
//     if (currentHeroIndex >= heroes.length) {
//         isEnemyTurn = true;
//         executeHeroActions();
//         return;
//     }

//     const hero = heroes[currentHeroIndex];
//     if (!hero.alive) {
//         currentHeroIndex++;
//         showHeroActionSelection();
//         return;
//     }

//     actions.innerHTML = `<strong>${hero.name}の行動を選択してください:</strong>`;
//     const atkButton = document.createElement('button');
//     atkButton.textContent = 'たたかう';

//     atkButton.onclick = () => {showEnemySelectionForAttack(hero)};
//     actions.appendChild(atkButton);

//     // 全員戦うボタンを追加 (testがtrueの時のみ表示)
//     if (test) {
//         const allAtkButton = document.createElement('button');
//         allAtkButton.textContent = '全員戦う';
//         allAtkButton.onclick = () => {
//             allHeroesAttack();
//         };
//         actions.appendChild(allAtkButton);
//     }

//     // 通常スペルの表示
//     Object.entries(SPELLS).forEach(([key, sp]) => {
//         if (hero.mp >= sp.cost) {
//             const spellButton = document.createElement('button');
//             spellButton.textContent = sp.name; // 日本語名を表示
//             spellButton.onclick = () => {
//                 const target = sp.type === 'heal' ? selectHeroTarget() : selectEnemyTarget();
//                 if (target) {
//                     actionsQueue.push({ hero, action: 'spell', spell: key, target });
//                     currentHeroIndex++;
//                     showHeroActionSelection();
//                 }
//             };
//             actions.appendChild(spellButton);
//         }
//     });

//     // 習得済みスペルの表示
//     if (hero.learnedSpells && hero.learnedSpells.length > 0) {
//         hero.learnedSpells.forEach(spellKey => {
//             const sp = ULT_SPELLS[spellKey];
//             if (hero.mp >= sp.cost) {
//                 const spellButton = document.createElement('button');
//                 spellButton.textContent = sp.name; // 日本語名を表示
//                 spellButton.onclick = () => {
//                     // const target = sp.range === 'all' ? null : (sp.type === 'heal' ? selectHeroTarget() : selectEnemyTarget());
//                     // effectがある場合はtargetをnullにする
//                     const target = sp.effect ? null : (sp.type === 'heal' ? selectHeroTarget() : selectEnemyTarget());

//                     if (sp.range === 'all' || target) {
//                         actionsQueue.push({ hero, action: 'spell', spell: spellKey, target });
//                         currentHeroIndex++;
//                         showHeroActionSelection();
//                     }
//                 };
//                 actions.appendChild(spellButton);
//             }
//         });
//     }

//     if (inventory.length > 0) {
//         const itemButton = document.createElement('button');
//         itemButton.textContent = 'アイテム';
//         function showItemSelection(hero) {
//             actions.innerHTML = `<strong>使用するアイテムを選択してください:</strong>`;
//             inventory.forEach((item, index) => {
//                 const itemButton = document.createElement('button');
//                 itemButton.textContent = item.name;
//                 itemButton.onclick = () => useItem(hero, index);
//                 actions.appendChild(itemButton);
//             });

//             const backButton = document.createElement('button');
//             backButton.textContent = '戻る';
//             backButton.onclick = () => showHeroActionSelection();
//             actions.appendChild(backButton);
//         }
//         itemButton.onclick = () => {showItemSelection(hero)};
//         actions.appendChild(itemButton);
//     }
// }

function showHeroActionSelection() {
    if (currentHeroIndex >= heroes.length) {
        isEnemyTurn = true;
        executeHeroActions();
        return;
    }

    const hero = heroes[currentHeroIndex];
    if (!hero.alive) {
        currentHeroIndex++;
        showHeroActionSelection();
        return;
    }

    actions.innerHTML = `<strong>${hero.name}の行動を選択してください:</strong>`;
    const atkButton = document.createElement('button');
    atkButton.textContent = 'たたかう';

    atkButton.onclick = () => {showEnemySelectionForAttack(hero)};
    actions.appendChild(atkButton);

    // 全員戦うボタンを追加 (testがtrueの時のみ表示)
    if (test) {
        const allAtkButton = document.createElement('button');
        allAtkButton.textContent = '全員戦う';
        allAtkButton.onclick = () => {
            allHeroesAttack();
        };
        actions.appendChild(allAtkButton);
    }

    // 通常スペルの表示
    Object.entries(SPELLS).forEach(([key, sp]) => {
        if (hero.mp >= sp.cost) {
            const spellButton = document.createElement('button');
            spellButton.textContent = sp.name; // 日本語名を表示
            spellButton.onclick = () => {
                // ターゲット選択が必要な場合は選択UIを表示
                if (sp.range === 'single') {
                    // --- ここを修正 ---
                    // 回復系は味方、攻撃系は敵、その他は両方
                    let targets = [];
                    if (sp.type === 'heal') {
                        targets = heroes.filter(h => h.alive);
                    } else if (sp.type === 'dmg') {
                        targets = enemies.filter(e => e.alive);
                    } else {
                        // buffやotherなどは味方も敵も選択肢に
                        targets = [
                            ...heroes.filter(h => h.alive),
                            ...enemies.filter(e => e.alive)
                        ];
                    }
                    actions.innerHTML = `<strong>対象を選択してください:</strong>`;
                    targets.forEach(target => {
                        const targetButton = document.createElement('button');
                        targetButton.textContent = target.name;
                        targetButton.onclick = () => {
                            actionsQueue.push({ hero, action: 'spell', spell: key, target });
                            currentHeroIndex++;
                            showHeroActionSelection();
                        };
                        actions.appendChild(targetButton);
                    });
                    // 戻るボタン
                    const backButton = document.createElement('button');
                    backButton.textContent = '戻る';
                    backButton.onclick = () => showHeroActionSelection();
                    actions.appendChild(backButton);
                } else {
                    // 全体魔法や特殊スペルは即実行
                    actionsQueue.push({ hero, action: 'spell', spell: key, target: null });
                    currentHeroIndex++;
                    showHeroActionSelection();
                }
            };
            actions.appendChild(spellButton);
        }
    });

    // 習得済みスペルの表示
    if (hero.learnedSpells && hero.learnedSpells.length > 0) {
        hero.learnedSpells.forEach(spellKey => {
            const sp = ULT_SPELLS[spellKey];
            if (hero.mp >= sp.cost) {
                const spellButton = document.createElement('button');
                spellButton.textContent = sp.name; // 日本語名を表示
                spellButton.onclick = () => {
                    // effectがある場合はtargetをnullにする
                    if (sp.range === 'single' && !sp.effect) {
                        const targets = sp.type === 'heal'
                            ? heroes.filter(h => h.alive)
                            : enemies.filter(e => e.alive);
                        actions.innerHTML = `<strong>対象を選択してください:</strong>`;
                        targets.forEach(target => {
                            const targetButton = document.createElement('button');
                            targetButton.textContent = target.name;
                            targetButton.onclick = () => {
                                actionsQueue.push({ hero, action: 'spell', spell: spellKey, target });
                                currentHeroIndex++;
                                showHeroActionSelection();
                            };
                            actions.appendChild(targetButton);
                        });
                        // 戻るボタン
                        const backButton = document.createElement('button');
                        backButton.textContent = '戻る';
                        backButton.onclick = () => showHeroActionSelection();
                        actions.appendChild(backButton);
                    } else {
                        actionsQueue.push({ hero, action: 'spell', spell: spellKey, target: null });
                        currentHeroIndex++;
                        showHeroActionSelection();
                    }
                };
                actions.appendChild(spellButton);
            }
        });
    }

    if (inventory.length > 0) {
        const itemButton = document.createElement('button');
        itemButton.textContent = 'アイテム';
        function showItemSelection(hero) {
            actions.innerHTML = `<strong>使用するアイテムを選択してください:</strong>`;
            inventory.forEach((item, index) => {
                const itemButton = document.createElement('button');
                itemButton.textContent = item.name;
                itemButton.onclick = () => useItem(hero, index);
                actions.appendChild(itemButton);
            });

            const backButton = document.createElement('button');
            backButton.textContent = '戻る';
            backButton.onclick = () => showHeroActionSelection();
            actions.appendChild(backButton);
        }
        itemButton.onclick = () => {showItemSelection(hero)};
        actions.appendChild(itemButton);
    }
}

function updateStats() {
    stats.innerHTML = heroes.map(hero => {
        const nextLevelExp = calculateExpForLevel(hero.level + 1) - hero.exp; // 次のレベルに必要な経験値を計算
        return `
            <div>
                ${hero.name} (${hero.job} Lv${hero.level}) 
                HP: ${hero.hp}/${hero.maxHp} 
                MP: ${hero.mp}/${hero.maxMp} 
                BUFF: ${JSON.stringify(hero.buffs.str)}
                EXP: ${hero.exp} 
                (次のLvまで: ${nextLevelExp > 0 ? nextLevelExp : 0})
            </div>
        `;
    }).join('');
}

function updateEnemies(){ 
    // enemiesDiv.innerHTML=enemies.map(e=>`<div class="enemy ${!e.alive?'dead':''}" data-id="${e.id}">${e.name} HP:${e.hp}/${e.maxHp}</div>`).join('');
    enemiesDiv.innerHTML=enemies.map(e=>`<div class="enemy ${!e.alive?'dead':''}" data-id="${e.id}">${e.name} HP:${e.hp}/${e.maxHp} MP:${e.mp}/${e.maxMp}</div>`).join('');
}

function spawnEnemies(count = 3) {
    enemies = [];
    const maxEnemyLevel = Math.max(...ENEMY_LIST.map(e => e.level));
    const minLevel = Math.min(Math.floor((battleCount - 1) / 2) + 1, maxEnemyLevel);
    const maxLevel = Math.min(minLevel + 1, maxEnemyLevel);

    let candidates = ENEMY_LIST.filter(e => e.level >= minLevel && e.level <= maxLevel); // 敵のレベルを調整
    if (candidates.length === 0) {
        candidates = ENEMY_LIST.filter(e => e.level === maxEnemyLevel);
    }

    for (let i = 0; i < count; i++) {
        const e = JSON.parse(JSON.stringify(candidates[rand(0, candidates.length - 1)]));
        e.maxHp = e.hp;
        e.alive = true;
        e.id = i;
        e.buffs = { hp: 0, mp: 0, str: 0 }; // 戦闘中の補正値
        enemies.push(e);
    }
}

function showBattleOptions() {
    actions.innerHTML = `
        <strong>次の戦闘を選択してください:</strong>
        ${ENEMY_VOLUME_ARRAY.map(volume => `<button onclick="startBattle(${volume})">敵${volume}体の戦闘</button>`).join('')}
    `;
    logWrite('次の戦闘の敵の数を選んでください。');
}

function visitInn() {    
    heroes = heroes.map(hero => {
        if (hero.alive) {
            return {
                ...hero,
                hp: hero.maxHp,
                mp: hero.maxMp
            };
        }
        return hero;
    });
    logWrite('宿屋で休んでHPとMPが全回復しました。');
    showBattleOptions(); // 次の戦闘選択肢を表示
}

function visitTemple() {
    function changeJob(heroIndex) {
        const hero = heroes[heroIndex];
        const availableJobs = Object.keys(JOBS).filter(job => job !== hero.job);
        actions.innerHTML = `<strong>${hero.name}の転職先を選んでください:</strong>`;
        availableJobs.forEach(job => {
            const jobButton = document.createElement('button');
            jobButton.textContent = job;
            jobButton.onclick = () => {
                function confirmChangeJob(heroIndex, newJob) {
                    const hero = heroes[heroIndex];
                    const oldJob = hero.job;
                    hero.jobHistory[oldJob] = hero.level; // 現在のジョブとレベルを履歴に保存
                    const oldStats = { maxHp: hero.maxHp, maxMp: hero.maxMp, }; // 転職処理
                    const newStats = JOBS[newJob];
                    hero.job = newJob;
                    hero.level = 1;
                    hero.exp = 0;
                    hero.maxHp = Math.floor(newStats.hp + oldStats.maxHp * STATUS_INHERITANCE_RATIO + rand(-2, 2));
                    hero.maxMp = Math.floor(newStats.mp + oldStats.maxMp * STATUS_INHERITANCE_RATIO + rand(-2, 2));
                    hero.hp = hero.maxHp;
                    hero.mp = hero.maxMp;

                    logWrite(`${hero.name}は${newJob}に転職しました！`);
                    actions.innerHTML = ''; // 転職後の選択肢を消す
                    showBattleOptions(); // 次の戦闘選択肢を表示
                }
                confirmChangeJob(heroIndex, job); // 転職を確定
            };
            actions.appendChild(jobButton);
        });
        const backButton = document.createElement('button');
        backButton.textContent = '戻る';
        backButton.onclick = visitTemple;
        actions.appendChild(backButton);
    }
    actions.innerHTML = heroes.map((hero, index) => `
      <div>
        <strong>${hero.name}</strong> (${hero.job} Lv${hero.level})
        <div>ジョブ履歴: ${Object.entries(hero.jobHistory || {}).map(([job, level]) => `${job}: Lv${level}`).join(', ') || 'なし'}</div>
        <button onclick="changeJob(${index})">転職する</button>
      </div>
    `).join('');
    logWrite('神殿で転職が可能です。');
    const backButton = document.createElement('button');
    backButton.textContent = '次の戦闘に進む';
    backButton.onclick = showBattleOptions; // 次の戦闘選択肢を表示
    actions.appendChild(backButton);
}

function visitTrainingGround() {
    actions.innerHTML = heroes.map((hero, index) => `
      <div>
        <strong>${hero.name}</strong> (${hero.job} Lv${hero.level})
        <div>ジョブ履歴: ${Object.entries(hero.jobHistory || {}).map(([job, level]) => `${job}: Lv${level}`).join(', ') || 'なし'}</div>
        <button onclick="showSkillOptions(${index})">スキルを習得する</button>
      </div>
    `).join('');
    logWrite('修行場でスキルを習得できます。');
    const backButton = document.createElement('button');
    backButton.textContent = '次の戦闘に進む';
    backButton.onclick = showBattleOptions; // 次の戦闘選択肢を表示
    actions.appendChild(backButton);
}

let currentHeroIndex = 0; // 現在行動を選択中の味方のインデックス
let actionsQueue = []; // 味方の行動キュー
let isEnemyTurn = false; // 現在のターンが敵かどうか
let battleCount = 1; // 戦闘回数を初期化

function allHeroesAttack() {
    heroes.filter(h => h.alive).forEach(hero => {
        const target = enemies.find(e => e.alive); // 最初の生存している敵をターゲット
        if (target) {
            actionsQueue.push({ hero, action: 'attack', target });
        }
    });
    executeHeroActions(); // 全員の攻撃を即時実行
}

function nextTurn() {
    updateStats();
    updateEnemies();
    actions.innerHTML = '';

    if (!heroes.some(h => h.alive)) {
      logWrite('全滅…ゲームオーバー');
      return;
    }

    if (!enemies.some(e => e.alive)) {
      giveExp();
      return;
    }

    if (isEnemyTurn) {
      enemyTurn();
    } else {
      currentHeroIndex = 0;
      actionsQueue = [];
      showHeroActionSelection();
    }
}

function showEnemySelectionForAttack(hero) {
    actions.innerHTML = `<strong>攻撃する敵を選んでください:</strong>`;
    enemies
        .filter(e => e.alive)
        .forEach(enemy => {
        const enemyButton = document.createElement('button');
        enemyButton.textContent = enemy.name;
        enemyButton.onclick = () => {
            actionsQueue.push({ hero, action: 'attack', target: enemy });
            currentHeroIndex++;
            showHeroActionSelection();
        };
        actions.appendChild(enemyButton);
        });
}

function selectEnemyTarget() {
    const aliveEnemies = enemies.filter(e => e.alive);
    if (aliveEnemies.length === 0) return null;
    const target = aliveEnemies[0]; // 最初の敵を選択（ランダムではなく順番に） 
    logWrite(`ターゲット: ${target.name}`);
    return target;
}

function selectHeroTarget() {
    const aliveHeroes = heroes.filter(h => h.alive);
    if (aliveHeroes.length === 0) return null;
    const target = aliveHeroes[0]; // 最初の味方を選択（ランダムではなく順番に）
    logWrite(`ターゲット: ${target.name}`);
    return target;
}

function executeHeroActions() {
    while (actionsQueue.length > 0) {
        const { hero, action, spell, target } = actionsQueue.shift();
        if (action === 'attack') { // strにbuffを加味したダメージ計算
            const baseStr = Math.floor(hero.maxHp * STR_PERCENTAGE);
            const totalStr = baseStr + hero.buffs.str; // buffs.strを加算
            const dmg = rand(totalStr, totalStr + 6); // strを基にダメージ計算
            target.hp -= dmg;
            logWrite(`${hero.name}の攻撃！${target.name}に${dmg}ダメージ！`);
            if (target.hp <= 0) {
                target.alive = false;
                target.hp = 0;
                logWrite(`${target.name}を倒した！`);
            }
        } 
        if (action === 'spell') {
            castSpell(hero, spell, target);
        }
    }
    nextTurn(); // 敵のターンへ
}

function castSpell(hero, spell, target) {
    const sp = SPELLS[spell] || ULT_SPELLS[spell];
    if (!sp) {
        logWrite(`${spell}は存在しないスペルです。`);
        return;
    }

    hero.mp -= sp.cost;

    console.log(0);
    if (sp.type === 'buff') {
        // 味方を指定してその味方にbuffをかける(もしくは味方全体にかける)
        const buffTarget = sp.range === 'all' ? heroes.filter(h => h.alive) : [target];
        // console.log(target);
        console.log(buffTarget);
        // console.log(source);
        sp.effect(buffTarget, hero);


        return;
    }

    // effectプロパティがあれば必ずそれを実行し、他の処理は行わない
    if (sp.type === 'other') {
        (typeof sp.effect === 'function') ? sp.effect(target, hero) : logWrite(`${spell}の効果を実行できませんでした。`);
        return;
    }
    console.log(1);
    // sp.type summonの場合の処理
    if (sp.type === 'summon') {
            console.log(2);

        // sp.effectを実行
        sp.effect(target=null, hero);
            console.log(3);

        // logWrite(`${hero.name}は召喚を唱えた！${summonedHero.name}が味方になった!!`);
        return;
    }
    

    switch (true) {
        case sp.range === 'all':
            (sp.type === 'heal' ? heroes.filter(h => h.alive) : enemies.filter(e => e.alive))
                .forEach(t => applySpellEffect(hero, spell, sp, t));
            break;
        case sp.type === 'heal':
            const healTarget = heroes.filter(h => h.alive).sort((a, b) => a.hp - b.hp)[0];
            healTarget && applySpellEffect(hero, spell, sp, healTarget);
            break;
        case sp.type === 'dmg':
            const dmgTarget = enemies.filter(e => e.alive).sort((a, b) => a.hp - b.hp)[0];
            dmgTarget && applySpellEffect(hero, spell, sp, dmgTarget);
            break;
        case sp.type === 'debuff':
            const debuffTarget = enemies.filter(e => e.alive).sort((a, b) => b.hp - a.hp)[0];
            debuffTarget && applySpellEffect(hero, spell, sp, debuffTarget);
            break;
        default:
            applySpellEffect(hero, spell, sp, target);
    }
}

function applySpellEffect(hero, spellName, sp, target) {
    if (sp.type === 'heal') {
        const healAmount = rand(...sp.val);
        target.hp = Math.min(target.maxHp, target.hp + healAmount);
        logWrite(`${hero.name}は${spellName}を唱えた！${target.name}のHPが${healAmount}回復した！`);
    } 
    if (sp.type === 'dmg') {
        const dmg = rand(...sp.val); // スペルのダメージをそのまま使用
        target.hp -= dmg;
        logWrite(`${hero.name}は${spellName}を唱えた！${target.name}に${dmg}ダメージ！`);
        if (target.hp <= 0) {
            target.alive = false;
            target.hp = 0;
            logWrite(`${target.name}を倒した！`);
        }
    }
}

function enemyTurn() {
    const aliveHeroes = heroes.filter(h => h.alive);
    if (aliveHeroes.length === 0) {
        logWrite('全滅…ゲームオーバー');
        return;
    }

    enemies.filter(e => e.alive).forEach(e => {
        const actionChance = Math.random();
        const target = heroes.filter(h => h.alive)[rand(0, heroes.filter(h => h.alive).length - 1)];
        const attack = () => {
            const dmg = rand(5, 15);
            target.hp -= dmg;
            target.hp <= 0
                ? (target.alive = false, target.hp = 0, logWrite(`${e.name}の攻撃！${target.name}は倒れた…`))
                : logWrite(`${e.name}の攻撃！${target.name}に${dmg}ダメージ！`);
        };
        const castSpell = () => {
            const dmgSpells = Object.entries(SPELLS).filter(([_, sp]) => sp.type === 'dmg' && e.mp >= sp.cost);
            if (dmgSpells.length > 0) {
                const [spellName, spell] = dmgSpells[rand(0, dmgSpells.length - 1)];
                e.mp -= spell.cost;
                const dmg = rand(...spell.val);
                target.hp -= dmg;
                target.hp <= 0
                    ? (target.alive = false, target.hp = 0, logWrite(`${e.name}は${spellName}を唱えた！${target.name}は倒れた…`))
                    : logWrite(`${e.name}は${spellName}を唱えた！${target.name}に${dmg}ダメージ！`);
            } else {
                logWrite(`${e.name}はMPが足りないため、何もしなかった…`);
            }
        };
        e.mp === 0
            ? attack()
            : actionChance < 0.1
                ? logWrite(`${e.name}は様子を見ている…`)
                : actionChance < 0.7
                    ? attack()
                    : castSpell();
    });

    isEnemyTurn = false; // 敵のターンが終わったら味方のターンに移行
    nextTurn();
}

const showGameOverScreen = () => {actions.innerHTML = `<button onclick="location.reload()">リスタート</button>`; logWrite('<strong>全滅…ゲームオーバー</strong>')};

function visitInn() {
    heroes = heroes.map(hero => {
        if (hero.alive) { // 生存しているキャラクターのみ回復
            return {
                ...hero,
                hp: hero.maxHp, // HPを最大値まで回復
                mp: hero.maxMp, // MPを最大値まで回復
                exp: 0 // 経験値をリセット
            };
        }
        return hero; // 死亡しているキャラクターはそのまま
    });
    logWrite('宿屋で休んでHPとMPが全回復しました!（経験値がリセットされました）');
    startBattle(); // 次の戦闘へ
}

const calculateExpForLevel = (level) => Math.floor(50 * Math.pow(1.5, level - 1)); // レベルアップに必要な経験値を計算

function giveExp() {
    function resetBuffs() {
        heroes.forEach(hero => {hero.buffs = { hp: 0, mp: 0, str: 0 }});
        enemies.forEach(enemy => {enemy.buffs = { hp: 0, mp: 0, str: 0 }});
    }
    resetBuffs();
    const clearLog = () => log.innerHTML = ''; // ログをクリアする関数
    clearLog();
    logWrite('敵を全滅させた！経験値を獲得！');
    let totalExp = enemies.reduce((sum, e) => sum + (e.alive ? 0 : e.exp), 0); // 倒した敵の経験値を合計
    let sharedExp = Math.floor(totalExp / heroes.length); // パーティ全員で等分
    heroes.forEach(hero => {
        if (!hero.alive) return; // 死亡しているキャラクターはスキップ
        hero.mp = hero.maxMp < hero.mp ? hero.maxMp : hero.mp; // 最大値を超えたMPを最大値に切り捨て(最大MPを超えてMPをチャージするスペルが存在するため)
        hero.exp += sharedExp; // 経験値を加算
        logWrite(`${hero.name}は${sharedExp}の経験値を得た！（現在の経験値: ${hero.exp}）`);
        while (hero.exp >= calculateExpForLevel(hero.level)) {
            hero.exp -= calculateExpForLevel(hero.level); // 現在のレベルに必要な経験値を差し引く
            hero.level++; // レベルアップ
            const growth = JOB_GROWTH[hero.job];
            hero.maxHp += rand(...growth.maxHp); // HP増加
            hero.maxMp += rand(...growth.maxMp); // MP増加
            hero.hp = hero.maxHp; // HPを全回復
            hero.mp = hero.maxMp; // MPを全回復
            hero.jobHistory[hero.job] = Math.max(hero.jobHistory[hero.job] || 0, hero.level); // ジョブ履歴を更新
            logWrite(`${hero.name}はLv${hero.level}に上がった！`);
        }
    });
    convertEnemyToAlly(); // 敵を仲間にする

    const droppedAccessories = dropAccessories(enemies.length); // アクセサリをドロップ
    droppedAccessories.length > 0 ? showAccessorySelection(droppedAccessories) : showInnOrTemple(); // アクセサリ装備選択画面を表示
}

function dropItems(enemyCount) { // 敵の数かけるVOLUME_DROPSのdrop
    const dropCount = enemyCount === 1 ? 1 : enemyCount * VOLUME_DROPS;
    for (let i = 0; i < dropCount; i++) {
        const randomItem = ITEM_LIST[rand(0, ITEM_LIST.length - 1)];
        inventory.push(randomItem); // インベントリに追加
        logWrite(`アイテム「${randomItem.name}」を入手しました！`);
    }
}

function useItem(hero, itemIndex) {
    const item = inventory[itemIndex];
    if (!item) return;
    if (item.type === 'buff') {
        applyBattleBuff(hero, item.buff, item.apply_type, item.val[0]);
        logWrite(`${hero.name}は「${item.name}」を使った！${hero.name}の${item.buff}が${item.val[0]}上昇した！`);
        inventory.splice(itemIndex, 1);
        return showHeroActionSelection();
    }
    if (item.type === 'heal' || item.type === 'mp') {
        item.range === 'single'
            ? showTargetSelection(hero, item, itemIndex)
            : (
                (item.type === 'heal' || item.type === 'mp') &&
                heroes.filter(h => h.alive).forEach(target => {
                    const amount = rand(...item.val);
                    item.type === 'heal'
                        ? (target.hp = Math.min(target.maxHp, target.hp + amount), logWrite(`${hero.name}は「${item.name}」を使った！${target.name}のHPが${amount}回復した！`))
                        : (target.mp = Math.min(target.maxMp, target.mp + amount), logWrite(`${hero.name}は「${item.name}」を使った！${target.name}のMPが${amount}回復した！`));
                }),
                inventory.splice(itemIndex, 1),
                showHeroActionSelection()
            );
    }
}

function showTargetSelection(hero, item, itemIndex) {
    actions.innerHTML = `<strong>対象を選択してください:</strong>`;
    const targets = item.type === 'heal' ? heroes.filter(h => h.alive) : heroes.filter(h => h.alive);

    targets.forEach(target => {
        const targetButton = document.createElement('button');
        targetButton.textContent = target.name;
        targetButton.onclick = () => {
            const amount = rand(...item.val);
            if (item.type === 'heal') {
                target.hp = Math.min(target.maxHp, target.hp + amount);
                logWrite(`${hero.name}は「${item.name}」を使った！${target.name}のHPが${amount}回復した！`);
            }
            if (item.type === 'mp') {
                target.mp = Math.min(target.maxMp, target.mp + amount);
                logWrite(`${hero.name}は「${item.name}」を使った！${target.name}のMPが${amount}回復した！`);
            }
            inventory.splice(itemIndex, 1); // アイテムを消費
            showHeroActionSelection(); // 次の行動選択へ
        };
        actions.appendChild(targetButton);
    });

    const backButton = document.createElement('button');
    backButton.textContent = '戻る';
    backButton.onclick = () => showHeroActionSelection();
    actions.appendChild(backButton);
}

function showEnding() {
    actions.innerHTML = `
      <h2>エンディング</h2>
      <p>勇者たちはすべての敵を倒し、世界に平和を取り戻しました。</p>
      <button onclick="location.reload()">もう一度プレイする</button>`;
    logWrite('<strong>ゲームクリア！おめでとうございます！</strong>');
}

function visitTrainingGround() {
    function showSkillOptions(heroIndex) {
        const hero = heroes[heroIndex]; // 1行関数で条件判定を分離
        const hasJobLevel = (job, lv) => (hero.jobHistory[job] || 0) >= lv;
        const canLearnSkill = ([, details]) =>
            Object.entries(details.requiredJobs).every(([job, lv]) => hasJobLevel(job, lv)); // スキル習得条件を満たすか判定
        const isSkillLearned = (spell) => hero.learnedSpells && hero.learnedSpells.includes(spell); // 既に習得済みか判定
        const availableSkills = Object.entries(ULT_SPELLS).filter(([spell, details]) => canLearnSkill([spell, details]) && !isSkillLearned(spell)); // 習得可能なスキルをフィルタリング
        if (availableSkills.length === 0) {logWrite(`${hero.name}は習得可能なスキルがありません。`); return; } // 習得可能なスキルがない場合はメッセージを表示

        function learnSkill(heroIndex, spell) {
            const hero = heroes[heroIndex];
            hero.learnedSpells = hero.learnedSpells || [];
            hero.learnedSpells.push(spell);
            logWrite(`${hero.name}は「${spell}」を習得しました！`);
            showBattleOptions();    // 戦闘選択肢に戻る    
        }
        
        actions.innerHTML = availableSkills.map(([spell, details]) => `
        <div>
            <strong>${details.name}</strong> (${details.type === 'dmg' ? '攻撃' : '回復'}) - MP: ${details.cost}
            <button onclick="learnSkill(${heroIndex}, '${spell}')">習得する</button>
        </div>
        `).join('');
    }

    actions.innerHTML = heroes.map((hero, index) => `
      <div>
        <strong>${hero.name}</strong> (${hero.job} Lv${hero.level})
        <div>ジョブ履歴: ${Object.entries(hero.jobHistory || {}).map(([job, level]) => `${job}: Lv${level}`).join(', ') || 'なし'}</div>
        <button onclick="showSkillOptions(${index})">スキルを習得する</button>
      </div>
    `).join('');

    logWrite('修行場でスキルを習得できます。');
    const backButton = document.createElement('button');
    backButton.textContent = '次の戦闘に進む';
    backButton.onclick = showBattleOptions; // 次の戦闘選択肢を表示
    actions.appendChild(backButton);
}

function showInnOrTemple() {
    updateStats(); // ステータスを画面に反映
    battleCount++; // 戦闘回数を増加
    actions.innerHTML = `
      <button onclick="visitInn()">宿屋に行く</button>
      <button onclick="visitTemple()">神殿に行く</button>
      <button onclick="visitTrainingGround()">修行場に行く</button>
      <button onclick="showBattleOptions()">次の戦闘に行く</button>`;
    logWrite('宿屋、神殿、修行場のいずれかを選んでください。または次の戦闘に進むこともできます。');
}

function convertEnemyToAlly() {
    if (heroes.length >= MAX_HEROES) {
        logWrite('味方の人数が最大です。これ以上仲間にできません。');
        showInnOrTemple(); // 仲間にできない場合は宿屋や神殿の選択肢を表示
        return;
    }
    const is_be_friend = () => Math.random() * 100 < ENEMY_FRIENDLY_PER; // 敵が仲間になりたがっている確率
    if (is_be_friend()) {
        const newAlly = defeatedEnemies[rand(0, defeatedEnemies.length - 1)];
        function addAlly(enemyName) {
            const defeatedEnemy = enemies.find(e => e.name === enemyName);
            if (!defeatedEnemy) return;
            const hero = createHero(defeatedEnemy.name, '戦士'); // 戦士として味方に追加
            hero.hp = hero.maxHp; // HPを全回復
            hero.mp = hero.maxMp; // MPを全回復
            hero.learnedSpells = []; // スペルは未習得
            heroes.push(hero);
            logWrite(`${defeatedEnemy.name}が味方になりました！`);
            actions.innerHTML = ''; // 選択画面を消す
            showInnOrTemple(); // 次の行動選択画面を表示
        }
        function rejectAlly(enemyName) {
            logWrite(`${enemyName}を仲間にするのを断りました。`);
            actions.innerHTML = ''; // 選択画面を消す
            showInnOrTemple(); // 次の行動選択画面を表示
        }
        actions.innerHTML = `
            <div>
                <strong>${newAlly.name}が味方になりたそうにこちらを見ている…</strong>
                <button onclick="addAlly('${newAlly.name}')">仲間にする</button>
                <button onclick="rejectAlly('${newAlly.name}')">断る</button>
            </div>
            `; // 選択画面を表示
    }else{
        showInnOrTemple(); // 仲間にできない場合は宿屋や神殿の選択肢を表示
    }
}

function applyBattleBuff(hero, stat, apply_type='add', value) {
    if (hero.buffs[stat] == undefined) {
        logWrite(`無効なステータス: ${stat}`);
        return;
    }
    if (apply_type === 'add') {
        hero.buffs[stat] += value;
        logWrite(`${hero.name}の${stat}が${value > 0 ? '+' : ''}${value}されました！`);
    } 
    if (apply_type === 'multiply') {
        hero.buffs[stat] += Math.floor(hero[stat] + hero.buffs[stat]) * value;
        logWrite(`${hero.name}の${hero[stat]}が${Math.floor(hero[stat] + hero.buffs[stat]) * value}${value}されました！`);
    }
}

startBattle();
</script>
</body>
</html>